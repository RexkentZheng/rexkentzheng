<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>前端刷题路-Day14</title>
    <link href="/rexkentzheng/2021/04/12/%E5%89%8D%E7%AB%AF%E5%88%B7%E9%A2%98%E8%B7%AF-Day14/"/>
    <url>/rexkentzheng/2021/04/12/%E5%89%8D%E7%AB%AF%E5%88%B7%E9%A2%98%E8%B7%AF-Day14/</url>
    
    <content type="html"><![CDATA[<h3 id="有效的数独（题号36）"><a href="#有效的数独（题号36）" class="headerlink" title="有效的数独（题号36）"></a>有效的数独（题号36）</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>判断一个 <code>9x9</code> 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。</p><p>数字 <code>1-9</code> 在每一行只能出现一次。<br>数字 <code>1-9</code> 在每一列只能出现一次。<br>数字 <code>1-9</code> 在每一个以粗实线分隔的 <code>3x3</code> 宫内只能出现一次。</p><p>数独部分空格内已填入了数字，空白格用 <code>&#39;.&#39;</code> 表示。</p><p>示例 1:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp">输入:  <br>[<span class="hljs-meta">  </span><br><span class="hljs-meta">  [<span class="hljs-meta-string">&quot;5&quot;</span>,<span class="hljs-meta-string">&quot;3&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;7&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span></span>],  <br>  [<span class="hljs-meta"><span class="hljs-meta-string">&quot;6&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;1&quot;</span>,<span class="hljs-meta-string">&quot;9&quot;</span>,<span class="hljs-meta-string">&quot;5&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span></span>],  <br>  [<span class="hljs-meta"><span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;9&quot;</span>,<span class="hljs-meta-string">&quot;8&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;6&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span></span>],  <br>  [<span class="hljs-meta"><span class="hljs-meta-string">&quot;8&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;6&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;3&quot;</span></span>],  <br>  [<span class="hljs-meta"><span class="hljs-meta-string">&quot;4&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;8&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;3&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;1&quot;</span></span>],  <br>  [<span class="hljs-meta"><span class="hljs-meta-string">&quot;7&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;2&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;6&quot;</span></span>],  <br>  [<span class="hljs-meta"><span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;6&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;2&quot;</span>,<span class="hljs-meta-string">&quot;8&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span></span>],  <br>  [<span class="hljs-meta"><span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;4&quot;</span>,<span class="hljs-meta-string">&quot;1&quot;</span>,<span class="hljs-meta-string">&quot;9&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;5&quot;</span></span>],  <br>  [<span class="hljs-meta"><span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;8&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;7&quot;</span>,<span class="hljs-meta-string">&quot;9&quot;</span></span>]  <br>]  <br>输出: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp">输入:  <br>[<span class="hljs-meta">  </span><br><span class="hljs-meta">  [<span class="hljs-meta-string">&quot;8&quot;</span>,<span class="hljs-meta-string">&quot;3&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;7&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span></span>],  <br>  [<span class="hljs-meta"><span class="hljs-meta-string">&quot;6&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;1&quot;</span>,<span class="hljs-meta-string">&quot;9&quot;</span>,<span class="hljs-meta-string">&quot;5&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span></span>],  <br>  [<span class="hljs-meta"><span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;9&quot;</span>,<span class="hljs-meta-string">&quot;8&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;6&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span></span>],  <br>  [<span class="hljs-meta"><span class="hljs-meta-string">&quot;8&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;6&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;3&quot;</span></span>],  <br>  [<span class="hljs-meta"><span class="hljs-meta-string">&quot;4&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;8&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;3&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;1&quot;</span></span>],  <br>  [<span class="hljs-meta"><span class="hljs-meta-string">&quot;7&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;2&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;6&quot;</span></span>],  <br>  [<span class="hljs-meta"><span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;6&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;2&quot;</span>,<span class="hljs-meta-string">&quot;8&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span></span>],  <br>  [<span class="hljs-meta"><span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;4&quot;</span>,<span class="hljs-meta-string">&quot;1&quot;</span>,<span class="hljs-meta-string">&quot;9&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;5&quot;</span></span>],  <br>  [<span class="hljs-meta"><span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;8&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;.&quot;</span>,<span class="hljs-meta-string">&quot;7&quot;</span>,<span class="hljs-meta-string">&quot;9&quot;</span></span>]  <br>]  <br>输出: <span class="hljs-literal">false</span><br>解释: 除了第一行的第一个数字从 <span class="hljs-number">5</span> 改为 <span class="hljs-number">8</span> 以外，空格内其他数字均与 示例<span class="hljs-number">1</span> 相同。<br>     但由于位于左上角的 <span class="hljs-number">3</span>x3 宫内有两个 <span class="hljs-number">8</span> 存在, 因此这个数独是无效的。<br></code></pre></td></tr></table></figure><p>说明:</p><ul><li>一个有效的数独（部分已被填充）不一定是可解的。</li><li>只需要根据以上规则，验证已经填入的数字是否有效即可。</li><li>给定数独序列只包含数字 <code>1-9</code> 和字符<code>&#39;.&#39;</code> 。</li><li>给定数独永远是 <code>9x9</code> 形式的。</li></ul><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><a href="https://leetcode-cn.com/problems/valid-sudoku/">https://leetcode-cn.com/problems/valid-sudoku/</a></p><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>这一题其实一眼看上去就直到解法了，问题在于具体怎么去实现。</p><p>主要就是找到行、列块的数组，判断里面有无重复数据</p><h4 id="自己的答案（数组去重）"><a href="#自己的答案（数组去重）" class="headerlink" title="自己的答案（数组去重）"></a>自己的答案（数组去重）</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeDot</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> arr.filter(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item !== <span class="hljs-string">&#x27;.&#x27;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isTurely</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> arr.length === <span class="hljs-built_in">Array</span>.from(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(arr)).length<br>&#125;<br><br><span class="hljs-keyword">var</span> isValidSudoku = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">board</span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>    <span class="hljs-keyword">var</span> rowArr = board[i]    <br>    <span class="hljs-keyword">if</span> (!isTurely(removeDot(rowArr))) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">var</span> cloArr = board.map(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item[i])<br>    <span class="hljs-keyword">if</span> (!isTurely(removeDot(cloArr))) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">if</span> ([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].indexOf((i + <span class="hljs-number">1</span>) / <span class="hljs-number">3</span>) &gt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">var</span> startI = ((i  + <span class="hljs-number">1</span>) / <span class="hljs-number">3</span> - <span class="hljs-number">1</span>) * <span class="hljs-number">3</span><br>          endI = startI + <span class="hljs-number">3</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++) &#123;<br>        <span class="hljs-keyword">var</span> startJ = j * <span class="hljs-number">3</span><br>            endJ = startJ + <span class="hljs-number">3</span><br>            arr = []<br>        <span class="hljs-keyword">while</span> (startJ &lt; endJ) &#123;<br>          arr = arr.concat(board[startJ].slice(startI, endI))<br>          startJ++<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!isTurely(removeDot(arr))) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>      &#125;    <br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>想法比较简单，找到行列块的数据后，往里面插入数据，插入数据后进行数组去重，如果去重后的结果和去重前的数组长度不一，那就GG，显然是有重复的。这里的问题就出在判断条件上，例用数组去重来判断是比较吃性能的一种行为。</p><h4 id="自己的答案（Map、Set）"><a href="#自己的答案（Map、Set）" class="headerlink" title="自己的答案（Map、Set）"></a>自己的答案（Map、Set）</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">var</span> isValidSudoku = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">board</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> newMap = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++) &#123;<br>      <span class="hljs-keyword">var</span> boardValue = board[i][j]<br>      <span class="hljs-keyword">if</span> (boardValue !== <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>        <span class="hljs-keyword">var</span> mapNameArr = [<span class="hljs-string">`line-<span class="hljs-subst">$&#123;i&#125;</span>`</span>, <span class="hljs-string">`row-<span class="hljs-subst">$&#123;j&#125;</span>`</span>, <span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">parseInt</span>(i <span class="hljs-regexp">/ 3)&#125;-$&#123;parseInt(j /</span> <span class="hljs-number">3</span>)&#125;</span>`</span>]<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>; k &lt; mapNameArr.length; k++) &#123;<br>          <span class="hljs-keyword">var</span> mapName = mapNameArr[k]<br>          <span class="hljs-keyword">var</span> mapRes = newMap.get(mapName)<br>          <span class="hljs-keyword">if</span> (mapRes) &#123;<br>            <span class="hljs-keyword">if</span> (mapRes.has(boardValue)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>            mapRes.add(boardValue)<br>            newMap.set(mapName, mapRes)<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            newMap.set(mapName, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([boardValue]))<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这其实是我看了一些解答之后自己又写的答案，有参考的嫌疑。</p><p>首先和第一种解法做比较，很容易看出来其实这里去掉了两个额外的函数，因为判断条件写在内部了。</p><p>接下来直接循环两次1~9，比上面的循环看上去更简单一些，重点是例用二维数组的特性。之后在循环内部拿到行列块数值，放到Set中进行比较，如果存在，直接GG，不存在就添加进去，确实方便了不少，而且Map和Set还有性能优势，不过由于生成的变量较多，空间复杂度有待改善。</p><h4 id="更好的方法（分开校验）"><a href="#更好的方法（分开校验）" class="headerlink" title="更好的方法（分开校验）"></a>更好的方法（分开校验）</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;character[][]&#125;</span> <span class="hljs-variable">board</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> isValidSudoku = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">board</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> mapRow = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(), mapColum = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i++) &#123; <span class="hljs-comment">// 先把横竖验了</span><br>        mapRow.clear()<br>        mapColum.clear()<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">9</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span> (mapRow.has(board[i][j])) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>            <span class="hljs-keyword">if</span> (mapColum.has(board[j][i])) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>            <span class="hljs-keyword">if</span> (board[i][j] !== <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>                mapRow.set(board[i][j], j)<br>            &#125;<br>            <span class="hljs-keyword">if</span> (board[j][i] !== <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>                mapColum.set(board[j][i], i)<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()<br>    <span class="hljs-keyword">let</span> m = <span class="hljs-number">0</span>, n = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> (m &lt; <span class="hljs-number">9</span>) &#123; <span class="hljs-comment">// 开始验块状</span><br>        <span class="hljs-keyword">while</span> (n &lt; <span class="hljs-number">9</span>) &#123;<br>            map.clear()<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = m; i &lt; m + <span class="hljs-number">3</span>; i++) &#123;<br>                <span class="hljs-keyword">for</span> (j = n; j &lt; n + <span class="hljs-number">3</span>; j++) &#123;<br>                    <span class="hljs-keyword">if</span> (map.has(board[i][j])) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>                    <span class="hljs-keyword">if</span> (board[i][j] !== <span class="hljs-string">&#x27;.&#x27;</span>) &#123;<br>                        map.set(board[i][j], j)<br>                    &#125;<br>                &#125;<br>            &#125;<br>            n += <span class="hljs-number">3</span><br>        &#125;<br>        m += <span class="hljs-number">3</span><br>        n = <span class="hljs-number">0</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>从时间复杂度和空间复杂度来说这确实可以说是比较优秀的一种解法了，二者都位居上游。</p><p>这里先利用两层<code>for</code>循环来校验行和列，校验完成后再使用<code>while</code>来对块进行校验，也是两层<code>for</code>循环，单由于循环次数较少，性能也是比较好的，每次只用循环当前的9个数据，很棒的一种解法。</p><p>并且它没有采用像我一样在Map中使用Set的方法，同一时间段数据量没有特别大，读写应该会更快些，值得学习</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前端刷题路-Day13</title>
    <link href="/rexkentzheng/2021/04/12/%E5%89%8D%E7%AB%AF%E5%88%B7%E9%A2%98%E8%B7%AF-Day13/"/>
    <url>/rexkentzheng/2021/04/12/%E5%89%8D%E7%AB%AF%E5%88%B7%E9%A2%98%E8%B7%AF-Day13/</url>
    
    <content type="html"><![CDATA[<h3 id="二叉树的最小深度（题号111）"><a href="#二叉树的最小深度（题号111）" class="headerlink" title="二叉树的最小深度（题号111）"></a>二叉树的最小深度（题号111）</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p>说明：叶子节点是指没有子节点的节点。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2020/10/12/ex_depth.jpg" alt="img"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">2</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">5</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">6</span>]<br>输出：<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>树中节点数的范围在 <code>[0, 105]</code> 内</li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/">https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/</a></p><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>这题写出了遍历，但是没写出递归，其实递归也不难，可能想得太复杂了</p><h4 id="自己的答案（递归）"><a href="#自己的答案（递归）" class="headerlink" title="自己的答案（递归）"></a>自己的答案（递归）</h4><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">var</span> minDepth = function (root) &#123;<br>  <span class="hljs-keyword">if</span> (!root) <span class="hljs-built_in">return</span> <span class="hljs-number">0</span><br>  <span class="hljs-built_in">var</span> arr = [root]<br>  <span class="hljs-built_in">var</span> level = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">while</span> (arr.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">var</span> aL = arr.<span class="hljs-built_in">length</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">let</span> i = <span class="hljs-number">0</span>; i &lt; aL; i++) &#123;<br>      <span class="hljs-built_in">var</span> node = arr.shift()<br>      <span class="hljs-keyword">if</span> (!node.left &amp;&amp; !node.right) &#123;<br>        arr.<span class="hljs-built_in">length</span> = <span class="hljs-number">0</span><br>        level++<br>        <span class="hljs-built_in">break</span><br>      &#125;<br>      <span class="hljs-keyword">if</span> (i === aL - <span class="hljs-number">1</span>) level++<br>      node.left &amp;&amp; arr.<span class="hljs-built_in">push</span>(node.left)<br>      node.right &amp;&amp; arr.<span class="hljs-built_in">push</span>(node.right)<br>    &#125;<br>  &#125;<br>  <span class="hljs-built_in">return</span> level<br>&#125;;<br></code></pre></td></tr></table></figure><p>没啥可说的，在对应的地方加上对应的代码即可。</p><h4 id="更好的方法（递归）"><a href="#更好的方法（递归）" class="headerlink" title="更好的方法（递归）"></a>更好的方法（递归）</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const minDepth =<span class="hljs-function"> (<span class="hljs-params">root</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (root<span class="hljs-operator"> == </span>null) &#123;            <span class="hljs-comment">// 递归到null节点，返回高度0</span><br>        return <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (root.left<span class="hljs-operator"> &amp;&amp; </span>root.right) &#123; <span class="hljs-comment">// 左右子树都存在，当前节点的高度1+左右子树递归结果的较小值</span><br>        return <span class="hljs-number">1</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>min(min<span class="hljs-constructor">Depth(<span class="hljs-params">root</span>.<span class="hljs-params">left</span>)</span>, min<span class="hljs-constructor">Depth(<span class="hljs-params">root</span>.<span class="hljs-params">right</span>)</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.left) &#123;        <span class="hljs-comment">// 左子树存在，右子树不存在</span><br>        return <span class="hljs-number">1</span> + min<span class="hljs-constructor">Depth(<span class="hljs-params">root</span>.<span class="hljs-params">left</span>)</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.right) &#123;       <span class="hljs-comment">// 右子树存在，左子树不存在</span><br>        return <span class="hljs-number">1</span> + min<span class="hljs-constructor">Depth(<span class="hljs-params">root</span>.<span class="hljs-params">right</span>)</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;                       <span class="hljs-comment">// 左右子树都不存在，光是当前节点的高度1</span><br>        return <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>一看代码就觉得挺简单的，没啥可说的</p><h4 id="更好的方法（递归）-1"><a href="#更好的方法（递归）-1" class="headerlink" title="更好的方法（递归）"></a>更好的方法（递归）</h4><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs coq">const minDepth = (root) =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (root == null) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    const <span class="hljs-built_in">left</span> = minDepth(root.<span class="hljs-built_in">left</span>);<br>    const <span class="hljs-built_in">right</span> = minDepth(root.<span class="hljs-built_in">right</span>);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">left</span> &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">right</span> &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + Math.min(<span class="hljs-built_in">left</span>, <span class="hljs-built_in">right</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">left</span> &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">left</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">right</span> &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">right</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>和上一种方法换汤不管药</p><h3 id="括号生成（题号22）"><a href="#括号生成（题号22）" class="headerlink" title="括号生成（题号22）"></a>括号生成（题号22）</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p><p>示例 1：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">3</span><br>输出：[<span class="hljs-string">&quot;((()))&quot;</span>,<span class="hljs-string">&quot;(()())&quot;</span>,<span class="hljs-string">&quot;(())()&quot;</span>,<span class="hljs-string">&quot;()(())&quot;</span>,<span class="hljs-string">&quot;()()()&quot;</span>]<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">1</span><br>输出：[<span class="hljs-string">&quot;()&quot;</span>]<br></code></pre></td></tr></table></figure><p>提示：</p><p><code>1 &lt;= n &lt;= 8</code></p><h4 id="链接-1"><a href="#链接-1" class="headerlink" title="链接"></a>链接</h4><p><a href="https://leetcode-cn.com/problems/generate-parentheses/">https://leetcode-cn.com/problems/generate-parentheses/</a></p><h4 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h4><p>用到了一个新知识——剪枝，就是在添加元素时判断是否满足条件，如果不满足条件，就不进行下一步操作，避免错误的形成。</p><p>查阅了一些相关答案，发现基本上都是这种方法，有用动态规划做这个的，但是代码比较复杂，难以理解。</p><h4 id="自己的答案"><a href="#自己的答案" class="headerlink" title="自己的答案"></a>自己的答案</h4><p>无</p><h4 id="更好的答案（DFS-剪枝）"><a href="#更好的答案（DFS-剪枝）" class="headerlink" title="更好的答案（DFS+剪枝）"></a>更好的答案（DFS+剪枝）</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">var generateParenthesis = <span class="hljs-keyword">function</span>(n) &#123;<br>  var <span class="hljs-built_in">list</span> = <span class="hljs-literal">[]</span><br>  get<span class="hljs-constructor">Str(<span class="hljs-params">n</span>, <span class="hljs-params">n</span>, &#x27;&#x27;)</span><br>  <span class="hljs-keyword">function</span> get<span class="hljs-constructor">Str(<span class="hljs-params">lL</span>, <span class="hljs-params">rL</span>, <span class="hljs-params">str</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (lL<span class="hljs-operator"> === </span><span class="hljs-number">0</span><span class="hljs-operator"> &amp;&amp; </span>rL<span class="hljs-operator"> === </span><span class="hljs-number">0</span>) &#123;<br>      return <span class="hljs-built_in">list</span>.push(str)<br>    &#125;<br>    <span class="hljs-keyword">if</span> (lL &gt; <span class="hljs-number">0</span>) &#123;<br>      get<span class="hljs-constructor">Str(<span class="hljs-params">lL</span> - 1, <span class="hljs-params">rL</span>, `$&#123;<span class="hljs-params">str</span>&#125;(`)</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (rL &gt; lL) &#123;<br>      get<span class="hljs-constructor">Str(<span class="hljs-params">lL</span>, <span class="hljs-params">rL</span> - 1, `$&#123;<span class="hljs-params">str</span>&#125;)</span>`)<br>    &#125;<br>  &#125;<br>  return <span class="hljs-built_in">list</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这一题是我想的太复杂了，总感觉有更好的解法，其实没有。</p><p>我本来的想法是通过规律来给出多种情况的组合条件，之后在递归中排列组合，可这其中的规律实在比较复杂，好像有点涉及到动态规划了，最后还是不了了之。</p><p>👆的这种解法其实是比较简单的，基本原理是一种往字符串中进行填充，但是填充时需要注意是不是满足条件，如果满足条件再进行填充，不满足就算了，这里的不满足就是剪枝了。</p><p>条件也比较简单，给定<code>lL</code>为左括号剩余数量，<code>rL</code>为右括号剩余数量。首先判断结束条件，当二者都为0时，判断为填充结束，向<code>list</code>中<code>push</code>字符串。</p><p>之后如果左括号还有剩余，那就往字符串中添加一个左括号。如果右括号的数量大于左括号，那就往字符串中添加一个右括号。只要满足这两个条件就可以得出正确的字符串。</p><p>逻辑比较简单，难的是想到这种方法。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前端刷题路-Day12</title>
    <link href="/rexkentzheng/2021/04/12/%E5%89%8D%E7%AB%AF%E5%88%B7%E9%A2%98%E8%B7%AF-Day12/"/>
    <url>/rexkentzheng/2021/04/12/%E5%89%8D%E7%AB%AF%E5%88%B7%E9%A2%98%E8%B7%AF-Day12/</url>
    
    <content type="html"><![CDATA[<h3 id="二叉树的层序遍历（题号102）"><a href="#二叉树的层序遍历（题号102）" class="headerlink" title="二叉树的层序遍历（题号102）"></a>二叉树的层序遍历（题号102）</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><p>示例：</p><p>二叉树：<code>[3,9,20,null,null,15,7]</code></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">3</span><br><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>返回其层序遍历结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">[<br>  [<span class="hljs-number">3</span>],<br>  [<span class="hljs-number">9</span>,<span class="hljs-number">20</span>],<br>  [<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br>]<br></code></pre></td></tr></table></figure><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">https://leetcode-cn.com/problems/binary-tree-level-order-traversal/</a></p><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>这题其实感觉比较简单，就是一层层的循环跟节点，逻辑上没有什么需要注意的，就是代码的书写上有一些需要注意的问题，看看👇的代码就知道了。</p><h4 id="自己的答案"><a href="#自己的答案" class="headerlink" title="自己的答案"></a>自己的答案</h4><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xquery">var levelOrder = <span class="hljs-keyword">function</span><span class="hljs-built_in">(root</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">!root</span>) <span class="hljs-keyword">return</span> []<br>  var arr1 = <span class="hljs-built_in">[root</span>]<br>      arr2 = []<br>  while (arr1.length &gt; <span class="hljs-number">0</span>) &#123;<br>    const &#123; val,<span class="hljs-built_in"> root</span> &#125; = arr1.reduce((total, <span class="hljs-type">item</span>) =&gt; &#123;<br>      total.val.push(<span class="hljs-type">item</span>.val)<br>      <span class="hljs-type">item</span>.left &amp;&amp; total<span class="hljs-built_in">.root</span>.push(<span class="hljs-type">item</span>.left)<br>      <span class="hljs-type">item</span>.right &amp;&amp; total<span class="hljs-built_in">.root</span>.push(<span class="hljs-type">item</span>.right)<br>      <span class="hljs-keyword">return</span> total<br>    &#125;, &#123; val: [],<span class="hljs-built_in"> root</span>: [] &#125;)<br>    arr1 =<span class="hljs-built_in"> root</span><br>    arr2.push(val)<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr2<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>arr1</code>用来存储节点，<code>arr2</code>用来存储最后的值。</p><p>首选处理<code>root</code>不存在的情况，这一点毋庸置疑。</p><p>之后开始遍历<code>arr1</code>，如果它存在，那么就循环它里面的内容，循环时要做两件事，首先拿到当前节点的值，之后拿到它的左节点和右节点，循环完毕后分别放到<code>arr1</code>和<code>arr2</code>中即可。</p><p>一开始用的是<code>map</code>，后来想了想，用了<code>reduce</code>，代码看上去确实更好一些，但感觉没有本质上的改变，依然需要两变量来存储每次循环后拿到的值，此时就有值得提升的地方了。</p><h4 id="更好的方法"><a href="#更好的方法" class="headerlink" title="更好的方法"></a>更好的方法</h4><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">var</span> levelOrder = function(root) &#123;<br>  <span class="hljs-keyword">if</span> (!root) <span class="hljs-built_in">return</span> []<br>  <span class="hljs-built_in">var</span> arr1 = [root]<br>      arr2 = []<br>  <span class="hljs-keyword">while</span> (arr1.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">var</span> arrL = arr1.<span class="hljs-built_in">length</span><br>    arr2.<span class="hljs-built_in">push</span>([])<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">let</span> i = <span class="hljs-number">0</span>; i &lt; arrL; i++) &#123;<br>      const node = arr1.shift();<br>      arr2[arr2.<span class="hljs-built_in">length</span> - <span class="hljs-number">1</span>].<span class="hljs-built_in">push</span>(node.val)<br>      node.left &amp;&amp; arr1.<span class="hljs-built_in">push</span>(node.left)<br>      node.right &amp;&amp; arr1.<span class="hljs-built_in">push</span>(node.right)<br>    &#125;<br>  &#125;<br>  <span class="hljs-built_in">return</span> arr2<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里相对于我自己的答案，并没有新建两个变量来存储节点和值，它其实利用了<code>while</code>的特性，我即使在内部修改<code>arr1</code>，但是在本次<code>while</code>循环结束前，其内部的<code>arr1</code>是不会受到影响的，那么就可以放心得对<code>arr1</code>和<code>arr2</code>进行处理了。</p><p>首先拿到循环前的<code>arr1</code>的长度，之后一个<code>for</code>循环，此时可以判断应该从<code>arr1</code>拿出几个节点，也不会拿太多，拿到下一轮循环的节点。</p><p>处理<code>arr2</code>是就更加简单了，在<code>for</code>循环开始前，先往<code>arr2</code>中插入一个空数组，之后在<code>for</code>循环中直接往<code>arr2</code>的最后一个元素中插入值即可，也不用新建一个变量来存储<code>for</code>循环中拿到的<code>val</code>来。</p><p>简单来说就是这样了，别的都没啥，就是细节都处理上不够到位，有待提高。</p><h3 id="二叉树的最大深度（题号104）"><a href="#二叉树的最大深度（题号104）" class="headerlink" title="二叉树的最大深度（题号104）"></a>二叉树的最大深度（题号104）</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p>示例：<br>给定二叉树 <code>[3,9,20,null,null,15,7]</code></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript"> <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>返回它的最大深度 3 。</p><h4 id="链接-1"><a href="#链接-1" class="headerlink" title="链接"></a>链接</h4><p><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/</a></p><h4 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h4><p>这题主要有两种方法来解答，一种是广度优先算法（Breadth-First-Search），一种是深度优先算法（Depth-First-Search）</p><h4 id="自己的答案（广度优先算法）"><a href="#自己的答案（广度优先算法）" class="headerlink" title="自己的答案（广度优先算法）"></a>自己的答案（广度优先算法）</h4><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xquery">var maxDepth = <span class="hljs-keyword">function</span><span class="hljs-built_in">(root</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">!root</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>  var level = <span class="hljs-number">0</span><br>      nodes = <span class="hljs-built_in">[root</span>]<br>  while (nodes.length &gt; <span class="hljs-number">0</span>) &#123;<br>    var nL = nodes.length<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nL; i++) &#123;<br>      var <span class="hljs-type">node</span> = nodes.shift()<br>      <span class="hljs-type">node</span>.left &amp;&amp; nodes.push(<span class="hljs-type">node</span>.left)<br>      <span class="hljs-type">node</span>.right &amp;&amp; nodes.push(<span class="hljs-type">node</span>.right)<br>      <span class="hljs-keyword">if</span> (i === nL - <span class="hljs-number">1</span>) level++<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> level<br>&#125;;<br></code></pre></td></tr></table></figure><p>这没啥可说的 ，上一题十分类似，横向遍历所有节点，然后累计遍历层数</p><h4 id="自己的答案（深度优先算法）"><a href="#自己的答案（深度优先算法）" class="headerlink" title="自己的答案（深度优先算法）"></a>自己的答案（深度优先算法）</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">var maxDepth = <span class="hljs-keyword">function</span> (node, length = <span class="hljs-number">0</span>) &#123;<br>  <span class="hljs-keyword">if</span> (node) &#123;<br>    var left = max<span class="hljs-constructor">Depth(<span class="hljs-params">node</span>.<span class="hljs-params">left</span>, <span class="hljs-params">length</span> + 1)</span><br>    right = max<span class="hljs-constructor">Depth(<span class="hljs-params">node</span>.<span class="hljs-params">right</span>, <span class="hljs-params">length</span> + 1)</span><br>    return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(left, right)<span class="hljs-operator"> || </span><span class="hljs-number">1</span> + length<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    return <span class="hljs-number">0</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这方法看上去不错，而且是纯自己想出来的，没有参考别的资料什么的。不过一如既往，还是有些小瑕疵的，比方说这一行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">return</span> Math.<span class="hljs-built_in">max</span>(<span class="hljs-keyword">left</span>, <span class="hljs-keyword">right</span>) <span class="hljs-operator">||</span> <span class="hljs-number">1</span> <span class="hljs-operator">+</span> length<br></code></pre></td></tr></table></figure><p>这里感觉是有些奇怪的，本来是这样的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">return</span> Math.<span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-keyword">left</span>, <span class="hljs-keyword">right</span>) <span class="hljs-operator">+</span> length<br></code></pre></td></tr></table></figure><p>可是怎么算都不对，之后无意间尝试了上面的一种写法，然后就对了，之后就很莫名其妙，为什么会对呢？原来上面的写法将整体的运算逻辑改变了，如果<code>Math.max</code>是0，就直接返回<code>1 + length</code>，这样整体逻辑就对了，</p><p>好好想想，如果还是不明白的话。</p><h4 id="更好的答案（深度优先算法）"><a href="#更好的答案（深度优先算法）" class="headerlink" title="更好的答案（深度优先算法）"></a>更好的答案（深度优先算法）</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> maxDepth = <span class="hljs-function">(<span class="hljs-params">root</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">const</span> leftMaxDepth = maxDepth(root.left);<br>  <span class="hljs-keyword">const</span> rightMaxDepth = maxDepth(root.right);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-built_in">Math</span>.max(leftMaxDepth, rightMaxDepth);<br>&#125;;<br></code></pre></td></tr></table></figure><p>毕竟是第一次写深度优先算法，看了看别人的，发现自己还是有提升空间的，首先来说可以将<code>root</code>不存在的情况提出来，后续就是根本不需要第二个<code>length</code>参数，只需要每次累计1即可，然后进行递归调用，这其实和求平方那一题有点像，完全不要一个<code>length</code>来进行中转，递归的过程中并不需要这个数。</p><p>所以说以后写代码不要着急，仔细想想在动笔，会清晰很多的。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前端刷题路-Day11</title>
    <link href="/rexkentzheng/2021/04/12/%E5%89%8D%E7%AB%AF%E5%88%B7%E9%A2%98%E8%B7%AF-Day11/"/>
    <url>/rexkentzheng/2021/04/12/%E5%89%8D%E7%AB%AF%E5%88%B7%E9%A2%98%E8%B7%AF-Day11/</url>
    
    <content type="html"><![CDATA[<h3 id="多数元素（题号169）"><a href="#多数元素（题号169）" class="headerlink" title="多数元素（题号169）"></a>多数元素（题号169）</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给定一个大小为 <code>n</code> 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 <code>⌊ n/2 ⌋</code> 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。 </p><p>示例 1：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[3,2,3]</span><br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：<span class="hljs-string">[2,2,1,1,1,2,2]</span><br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>进阶：</p><p>尝试设计时间复杂度为 <code>O(n)</code>、空间复杂度为 <code>O(1)</code> 的算法解决此问题。</p><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><a href="https://leetcode-cn.com/problems/majority-element/">https://leetcode-cn.com/problems/majority-element/</a></p><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>这题重点有两个，一个是<code>n / 2</code>，一个是必然会出现。</p><p>有了这两个限定条件解决方案就很多 了，比较不好理解的是抵消法，当然了这种方法也是最优解。</p><h4 id="自己的答案"><a href="#自己的答案" class="headerlink" title="自己的答案"></a>自己的答案</h4><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">var</span> majorityElement = function(nums) &#123;<br>  <span class="hljs-built_in">var</span> obj = <span class="hljs-built_in">new</span> Map()<br>  <span class="hljs-built_in">var</span> res = <span class="hljs-number">0</span><br>  <span class="hljs-built_in">var</span> <span class="hljs-built_in">max</span> = nums.<span class="hljs-built_in">length</span> /<span class="hljs-number">2</span><br>  <span class="hljs-keyword">while</span> (nums.<span class="hljs-built_in">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">var</span> item = nums[<span class="hljs-number">0</span>]<br>    obj.set(item, obj.has(item) ? obj.<span class="hljs-built_in">get</span>(item) + <span class="hljs-number">1</span> : <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">if</span> (obj.<span class="hljs-built_in">get</span>(item) &gt; <span class="hljs-built_in">max</span>) &#123;<br>      res = item<br>      nums.<span class="hljs-built_in">length</span> = <span class="hljs-number">0</span><br>    &#125;<br>    nums.shift()<br>  &#125;<br>  <span class="hljs-built_in">return</span> res<br>&#125;;<br></code></pre></td></tr></table></figure><p>这是第一次给出的答案，当时还挺开心的，毕竟是做出来了，后来才发现是粑粑一坨。</p><p>这块一个很明显的问题就是在满足条件时没有终止循环，完全没有意义，所以第二次写这题时改进了一波👇：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">var</span> majorityElement = function(nums) &#123;<br>  <span class="hljs-built_in">var</span> obj = &#123;&#125;<br>      res = <span class="hljs-number">0</span><br>      len = nums.<span class="hljs-built_in">length</span><br>      <span class="hljs-built_in">max</span> = ~~(len / <span class="hljs-number">2</span>)<br>  <span class="hljs-keyword">for</span> (<span class="hljs-built_in">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>    <span class="hljs-built_in">var</span> <span class="hljs-built_in">num</span> = nums[i]<br>    obj[<span class="hljs-built_in">num</span>] = obj[<span class="hljs-built_in">num</span>] ? ++obj[<span class="hljs-built_in">num</span>] : <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> (obj[<span class="hljs-built_in">num</span>] &gt; <span class="hljs-built_in">max</span>) &#123;<br>      res = <span class="hljs-built_in">num</span><br>      <span class="hljs-built_in">break</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-built_in">return</span> res<br>&#125;;<br></code></pre></td></tr></table></figure><p>是不是清爽了不少，并且在满足条件时直接终止，这里其实用<code>Map</code>的话性能会更好些。</p><h4 id="更好的方法（排序）"><a href="#更好的方法（排序）" class="headerlink" title="更好的方法（排序）"></a>更好的方法（排序）</h4><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;number[]&#125; nums</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;number&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> majorityElement = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(nums)</span> </span>&#123;<br>  nums.sort()<br>  <span class="hljs-keyword">return</span> nums[~~(nums.length / <span class="hljs-number">2</span>)]<br>&#125;;<br></code></pre></td></tr></table></figure><p>这没啥可说的，数组排序后，多数元素必然出现在数组的中间，写起来简单，但排序的时间复杂度是O（NlogN），并不是最优解。</p><p>需要注意的是<code>sort</code>方法，该方法如果不传任何参数，默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的。</p><p>也就是并非是从小到大的顺序，虽然它有时候看上去挺像的。</p><p>不过这里没有什么关系，顺序的不同并不会影响元素的数量，用就完事了。</p><h4 id="更好的方法（栈）"><a href="#更好的方法（栈）" class="headerlink" title="更好的方法（栈）"></a>更好的方法（栈）</h4><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">var</span> majorityElement = function(nums) &#123;<br>  let <span class="hljs-keyword">stack</span> = []<br>  <span class="hljs-keyword">for</span>(let <span class="hljs-keyword">n</span> of nums)&#123;<br>    let <span class="hljs-keyword">m</span> = <span class="hljs-keyword">stack</span>.length<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">stack</span>[<span class="hljs-keyword">m</span> - 1] === <span class="hljs-keyword">n</span> || !<span class="hljs-keyword">m</span>)&#123;<br>      <span class="hljs-keyword">stack</span>.push(<span class="hljs-keyword">n</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">stack</span>.pop()<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">stack</span>[0]<br>&#125;;<br></code></pre></td></tr></table></figure><p>该方法利用了数量优势，因为多数元素的数量必然是最多的，然后和其他元素相抵消。</p><p>就一个个往栈里推，如果最后一个元素和当前元素不同，则去掉栈顶的元素，那么占有绝对数量优势的多数元素则会取得最后的胜利。</p><h4 id="更好的方法3（抵消）"><a href="#更好的方法3（抵消）" class="headerlink" title="更好的方法3（抵消）"></a>更好的方法3（抵消）</h4><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nix">var <span class="hljs-attr">majorityElement</span> = function(nums) &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">x</span> = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">m</span> = <span class="hljs-number">0</span><br>  for(<span class="hljs-keyword">let</span> n of nums)&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-attr">m</span> === <span class="hljs-number">0</span>) <span class="hljs-attr">x</span> = n<br>    m += <span class="hljs-attr">x</span> === n ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span><br>  &#125;<br>  return x<br>&#125;;<br></code></pre></td></tr></table></figure><p>这就是直接抵消了，和栈相比多了一个变量，但是少了对栈的操作，就酱。</p><p>注意，栈和抵消方法其实都需要遍历完整个数组，但是笔者的答案有些时候并不需要遍历完整个数组。</p><h3 id="买卖股票的最佳时机-II（题号122）"><a href="#买卖股票的最佳时机-II（题号122）" class="headerlink" title="买卖股票的最佳时机 II（题号122）"></a>买卖股票的最佳时机 II（题号122）</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1:</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第<span class="hljs-number"> 2 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 3 </span>天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 =<span class="hljs-number"> 4 </span>。<br>     随后，在第<span class="hljs-number"> 4 </span>天（股票价格 = 3）的时候买入，在第<span class="hljs-number"> 5 </span>天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 =<span class="hljs-number"> 3 </span>。<br></code></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: [1,2,3,4,5]<br>输出: 4<br>解释: 在第<span class="hljs-number"> 1 </span>天（股票价格 = 1）的时候买入，在第<span class="hljs-number"> 5 </span>天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 =<span class="hljs-number"> 4 </span>。<br>     注意你不能在第<span class="hljs-number"> 1 </span>天和第<span class="hljs-number"> 2 </span>天接连购买股票，之后再将它们卖出。<br>     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。<br></code></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [7,6,4,3,1]</span><br><span class="hljs-section">输出: 0</span><br><span class="hljs-section">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= prices.length &lt;= 3 * 10 ^ 4</code></li><li><code>0 &lt;= prices[i] &lt;= 10 ^ 4</code></li></ul><h4 id="链接-1"><a href="#链接-1" class="headerlink" title="链接"></a>链接</h4><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/</a></p><h4 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h4><p>这题其实很简单，不用想的太复杂，什么后一个数如果比前一个数大，再判断下一个是是不是比之前大数更大等等，这样的逻辑反而更加复杂。</p><p>在后者比前者大时，直接取两者的差累计给<code>res</code>即可，但这里需要注意一下性能问题，笔者就发现了一些微小的差异。</p><h4 id="自己的答案（循环）"><a href="#自己的答案（循环）" class="headerlink" title="自己的答案（循环）"></a>自己的答案（循环）</h4><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scilab">var maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(prices)</span> &#123;</span><br>    var <span class="hljs-built_in">max</span> = <span class="hljs-number">0</span>;<br>    var <span class="hljs-built_in">size</span> = prices.<span class="hljs-built_in">length</span>;<br>        <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">size</span> - <span class="hljs-number">1</span>; i++)<br>            <span class="hljs-keyword">if</span> (prices[i] &lt; prices[i + <span class="hljs-number">1</span>])<br>                <span class="hljs-built_in">max</span> += prices[i + <span class="hljs-number">1</span>] - prices[i];<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>当时直接用的<code>for</code>循环，很简单，也很有效，这还是一年前的答案。</p><h4 id="自己的答案（reduce）"><a href="#自己的答案（reduce）" class="headerlink" title="自己的答案（reduce）"></a>自己的答案（reduce）</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> prices.reduce(<span class="hljs-function">(<span class="hljs-params">total, val, i</span>) =&gt;</span> prices[i] &lt; prices[i + <span class="hljs-number">1</span>] ? total + prices[i + <span class="hljs-number">1</span>] - prices[i] : total, <span class="hljs-number">0</span>)<br>&#125;;<br></code></pre></td></tr></table></figure><p>一个简单的<code>reduce</code>。注意，这里通过判断下一个数是否比当前数大来判断是否需要进行数据累计，这个判断其实是比较耗性能的，下面的写法确实比这种写法的性能好一些。</p><h4 id="更好的答案（Math-max）"><a href="#更好的答案（Math-max）" class="headerlink" title="更好的答案（Math.max）"></a>更好的答案（Math.max）</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">var</span> maxProfit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">prices</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> prices.reduce(<span class="hljs-function">(<span class="hljs-params">total, val, i</span>) =&gt;</span> total += i ? <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, prices[i] - prices[i - <span class="hljs-number">1</span>]) : total, <span class="hljs-number">0</span>)<br>&#125;;<br></code></pre></td></tr></table></figure><p>同样，也是一个<code>reduce</code>。但注意内部实现细节，这里通过<code>Math.max</code>来进行取值，所以省去了判断下一个元素是否大于当前元素的判断，确实省掉了一部分判断，这一部分判断大概节省了20毫秒左右的时间，却让执行用时从10%一下跳到了70%以上，最好的甚至到了90%以上，还是细节决定成败啊。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前端刷题路-Day10</title>
    <link href="/rexkentzheng/2021/04/12/%E5%89%8D%E7%AB%AF%E5%88%B7%E9%A2%98%E8%B7%AF-Day10/"/>
    <url>/rexkentzheng/2021/04/12/%E5%89%8D%E7%AB%AF%E5%88%B7%E9%A2%98%E8%B7%AF-Day10/</url>
    
    <content type="html"><![CDATA[<h3 id="二叉树的最近公共祖先（题号235、236）"><a href="#二叉树的最近公共祖先（题号235、236）" class="headerlink" title="二叉树的最近公共祖先（题号235、236）"></a>二叉树的最近公共祖先（题号235、236）</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>示例 1：</p><p>输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>输出：3<br>解释：节点 5 和节点 1 的最近公共祖先是节点 3 。<br>示例 2：</p><p>输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4<br>输出：5<br>解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。<br>示例 3：</p><p>输入：root = [1,2], p = 1, q = 2<br>输出：1</p><p>提示：</p><p>树中节点数目在范围 [2, 105] 内。<br>-109 &lt;= Node.val &lt;= 109<br>所有 Node.val 互不相同 。<br>p != q<br>p 和 q 均存在于给定的二叉树中。</p><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><ul><li>普通二叉树<br>  <a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/</a>  </li><li>二叉搜索树<br>  <a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/">https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/</a></li></ul><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>这是LeetCode的235和236两题，由于内容差不多，就放在一起了。</p><p>首先说说普通二叉树的解法，这种方法就有点不好理解了，但代码看上去十分简洁易懂，首先，判断当前节点是不是<code>null</code>如果是，直接返回，这一点毋庸置疑。</p><p>之后判断<code>root</code>是否等于<code>q</code>或者<code>p</code>，如果等于两者其中之一，就返回<code>root</code>节点。之后递归调用该函数，传入左节点和右节点，拿到左边和右边的值，如果左边的值是<code>null</code>，那证明<code>q</code>和<code>p</code>都在右边，如果右边的值是<code>null</code>，那么返回左边，如果两边都是<code>null</code>，那么直接返回<code>root</code>节点，因为显然<code>root</code>节点就是<code>q</code>和<code>p</code>的最近公共祖先了。</p><p>如果还是看不懂的话，就自己画图想想，或者去LeetCode看看答案，里面有图解，应该会有所帮助。</p><p>解决完普通二叉树后，二叉搜索树就简单很多了，因为可以利用它左右节点的大小关系来进行更简单的判断，条件也更清楚，而且这里可以使用递归和遍历两种方法，可操作性也更多了。</p><h4 id="自己的答案"><a href="#自己的答案" class="headerlink" title="自己的答案"></a>自己的答案</h4><p>无</p><h4 id="更好的方法（普通二叉树-递归）"><a href="#更好的方法（普通二叉树-递归）" class="headerlink" title="更好的方法（普通二叉树-递归）"></a>更好的方法（普通二叉树-递归）</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> lowestCommonAncestor = function(root, p, q) &#123;<br>  <span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>  <span class="hljs-keyword">if</span> (root.<span class="hljs-keyword">val</span> === q.<span class="hljs-keyword">val</span> || root.<span class="hljs-keyword">val</span> === p.<span class="hljs-keyword">val</span>) <span class="hljs-keyword">return</span> root<br>  <span class="hljs-keyword">var</span> left = lowestCommonAncestor(root.left, p, q)<br>      right = lowestCommonAncestor(root.right, p, q)<br>  <span class="hljs-keyword">if</span> (left === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> right<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span> (right === <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> left<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> root<br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里为了更直观，在判断上采用了<code>root === null</code>的写法，其实<code>!root</code>也是可以的。</p><h4 id="更好的方法（二叉搜索树-递归）"><a href="#更好的方法（二叉搜索树-递归）" class="headerlink" title="更好的方法（二叉搜索树-递归）"></a>更好的方法（二叉搜索树-递归）</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">var lowestCommonAncestor = <span class="hljs-keyword">function</span>(root, p, q) &#123;<br>  <span class="hljs-keyword">if</span> (!root) return root<br>  <span class="hljs-keyword">if</span> (root.<span class="hljs-keyword">val</span> &gt; p.<span class="hljs-keyword">val</span><span class="hljs-operator"> &amp;&amp; </span>root.<span class="hljs-keyword">val</span> &gt; q.<span class="hljs-keyword">val</span>) &#123;<br>    return lowest<span class="hljs-constructor">CommonAncestor(<span class="hljs-params">root</span>.<span class="hljs-params">left</span>, <span class="hljs-params">p</span>, <span class="hljs-params">q</span>)</span><br>  &#125;<br>  <span class="hljs-keyword">if</span> (root.<span class="hljs-keyword">val</span> &lt; p.<span class="hljs-keyword">val</span><span class="hljs-operator"> &amp;&amp; </span>root.<span class="hljs-keyword">val</span> &lt; q.<span class="hljs-keyword">val</span>) &#123;<br>    return lowest<span class="hljs-constructor">CommonAncestor(<span class="hljs-params">root</span>.<span class="hljs-params">right</span>, <span class="hljs-params">p</span>, <span class="hljs-params">q</span>)</span><br>  &#125;<br>  return root<br>&#125;;<br></code></pre></td></tr></table></figure><p>此为递归解法，如果根节点的值同时小于<code>p</code>和<code>q</code>的值，那么证明<code>p</code>和<code>q</code>在根节点的右边，之后递归调用右节点的值；同理可得，如果同时大于<code>p</code>和<code>q</code>，那么证明<code>p</code>和<code>在根节点的左侧，取左子树进行下一步递归，最后不能满足同时大于或者小于`p`和</code>值，那么证明当前的<code>root</code>就是二者的最近公共祖先节点，返回即可。</p><h4 id="更好的方法2（二叉搜索树-遍历）"><a href="#更好的方法2（二叉搜索树-遍历）" class="headerlink" title="更好的方法2（二叉搜索树-遍历）"></a>更好的方法2（二叉搜索树-遍历）</h4><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xquery">var lowestCommonAncestor = <span class="hljs-keyword">function</span><span class="hljs-built_in">(root</span>, p, q) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">!root</span>) <span class="hljs-keyword">return</span><span class="hljs-built_in"> root</span><br>  while <span class="hljs-built_in">(root</span>) &#123;<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">(root</span>.val &gt; p.val &amp;&amp;<span class="hljs-built_in"> root</span>.val &gt; q.val) &#123;<br>     <span class="hljs-built_in"> root</span> =<span class="hljs-built_in"> root</span>.left<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">(root</span>.val &lt; p.val &amp;&amp;<span class="hljs-built_in"> root</span>.val &lt; q.val) &#123;<br>     <span class="hljs-built_in"> root</span> =<span class="hljs-built_in"> root</span>.right <br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span><span class="hljs-built_in"> root</span><br>    &#125;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>此写法为遍历写法，整体逻辑和递归类似，可以理解为一种不同的写法，在此不多做赘述，看看即可。</p><h3 id="Pow-x-n-（题号50）"><a href="#Pow-x-n-（题号50）" class="headerlink" title="Pow(x, n)（题号50）"></a>Pow(x, n)（题号50）</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。</p><p>示例 1：</p><p>输入：x = 2.00000, n = 10<br>输出：1024.00000<br>示例 2：</p><p>输入：x = 2.10000, n = 3<br>输出：9.26100<br>示例 3：</p><p>输入：x = 2.00000, n = -2<br>输出：0.25000<br>解释：2-2 = 1/22 = 1/4 = 0.25</p><p>提示：</p><p>-100.0 &lt; x &lt; 100.0<br>-231 &lt;= n &lt;= 231-1<br>-104 &lt;= xn &lt;= 104</p><h4 id="链接-1"><a href="#链接-1" class="headerlink" title="链接"></a>链接</h4><p><a href="https://leetcode-cn.com/problems/powx-n/">https://leetcode-cn.com/problems/powx-n/</a></p><h4 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h4><p>这块就有点涉及到数学知识了，乍一看是很简单的一题，一直<code>n-1</code>即可，但实时告诉我没这么简单，在提交时发现<code>n</code>可能会巨大，然后就内存不足了，直接GG。</p><p>那么这个时候就要考虑到时间复杂度了，<code>n-1</code>的时间复杂度时O（n），此时显然需要降低时间复杂度，数学渣渣的我自然时没办法想出来的，讲真，看了答案后才知道，如果不看答案我应该永远都不会想到这种方法。</p><p>主要的逻辑很简单，利用幂的特性，如果幂指数为<code>n</code>，那么可以利用<code>n / 2</code>来减少一次递归或者遍历，此时之需要将本来的指改为其平方即可，由<code>x</code>变为<code>x * x</code>，这就完事了，那么具体到代码中去可能还需要考虑<code>n</code>的奇偶性，如果时奇数，那么需要用<code>x</code>来乘上上一步的结果，然后将<code>n</code>改为<code>n-1</code>，继续进行下一步循环。</p><p>到了这里这题就很简单了，直接看答案即可。</p><h4 id="自己的答案-1"><a href="#自己的答案-1" class="headerlink" title="自己的答案"></a>自己的答案</h4><p>无</p><h4 id="更好的方法（遍历）"><a href="#更好的方法（遍历）" class="headerlink" title="更好的方法（遍历）"></a>更好的方法（遍历）</h4><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">var</span> myPow = function(x, <span class="hljs-built_in">n</span>) &#123;<br>  <span class="hljs-built_in">if</span> (<span class="hljs-built_in">n</span> === <span class="hljs-number">0</span>) return <span class="hljs-number">1</span><br>  <span class="hljs-built_in">if</span> (<span class="hljs-built_in">n</span> &lt; <span class="hljs-number">0</span>) return myPow(<span class="hljs-number">1</span> / x, -<span class="hljs-built_in">n</span>)<br>  <span class="hljs-built_in">var</span> res = <span class="hljs-number">1</span><br>  while (<span class="hljs-built_in">n</span> &gt; <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-built_in">if</span> (<span class="hljs-built_in">n</span> % <span class="hljs-number">2</span> === <span class="hljs-number">1</span>) &#123;<br>      res = res * x<br>      <span class="hljs-built_in">n</span>--<br>    &#125;<br>    x = x * x<br>    <span class="hljs-built_in">n</span> = <span class="hljs-built_in">n</span> / <span class="hljs-number">2</span><br>  &#125;<br>  return res * x<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="更好的方法（递归）"><a href="#更好的方法（递归）" class="headerlink" title="更好的方法（递归）"></a>更好的方法（递归）</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">var myPow = <span class="hljs-keyword">function</span>(x, n) &#123;<br>  <span class="hljs-keyword">if</span> (n<span class="hljs-operator"> === </span><span class="hljs-number">0</span>) return <span class="hljs-number">1</span><br>  <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>) return my<span class="hljs-constructor">Pow(1 <span class="hljs-operator">/</span> <span class="hljs-params">x</span>, -<span class="hljs-params">n</span>)</span><br>  return n % <span class="hljs-number">2</span><span class="hljs-operator"> === </span><span class="hljs-number">1</span> ? x<span class="hljs-operator"> * </span>my<span class="hljs-constructor">Pow(<span class="hljs-params">x</span>, <span class="hljs-params">n</span> - 1)</span> : my<span class="hljs-constructor">Pow( <span class="hljs-params">x</span> <span class="hljs-operator">*</span> <span class="hljs-params">x</span>, <span class="hljs-params">n</span> <span class="hljs-operator">/</span> 2 )</span><br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前端刷题路-Day9</title>
    <link href="/rexkentzheng/2021/04/07/%E5%89%8D%E7%AB%AF%E5%88%B7%E9%A2%98%E8%B7%AF-Day9/"/>
    <url>/rexkentzheng/2021/04/07/%E5%89%8D%E7%AB%AF%E5%88%B7%E9%A2%98%E8%B7%AF-Day9/</url>
    
    <content type="html"><![CDATA[<h3 id="验证二叉搜索树（题号98）"><a href="#验证二叉搜索树（题号98）" class="headerlink" title="验证二叉搜索树（题号98）"></a>验证二叉搜索树（题号98）</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含小于当前节点的数。</li><li>节点的右子树只包含大于当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><p>示例 1:</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入:<br>    <span class="hljs-number">2</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">1</span>   <span class="hljs-number">3</span><br>输出: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入:<br>    <span class="hljs-number">5</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">1</span>   <span class="hljs-number">4</span><br>     / <span class="hljs-string">\</span><br>    <span class="hljs-number">3</span>   <span class="hljs-number">6</span><br>输出: <span class="hljs-literal">false</span><br>解释: 输入为: [<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>]。<br>     根节点的值为 <span class="hljs-number">5</span> ，但是其右子节点值为 <span class="hljs-number">4</span> 。<br></code></pre></td></tr></table></figure><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">https://leetcode-cn.com/problems/validate-binary-search-tree/</a></p><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>这就涉及到了二叉搜索树的基本定义了，定义很简单，所有左子树的值一定比当前节点的值小，同时所有右子树的值一定比当前节点的值大。注意，这里的定义是所有的值，并不局限在某一层。</p><p>一开始毫无头绪，这是第一次遇到有左右的情况，对于如何遍历没有什么好的想法，后续才发现原来迭代的方法十分简单，但是遍历好像只有中序遍历的答案，这让我有点小惊讶，还以为会有普通遍历的解法，可是看了许久也么有找到，有点奇怪。</p><h4 id="自己的答案（递归）"><a href="#自己的答案（递归）" class="headerlink" title="自己的答案（递归）"></a>自己的答案（递归）</h4><p>👇是笔者解题心路历程。</p><p>首先，笔者很快就写出来一个答案，利用的就是二叉搜索树的特点，左节点的值会小于当前节点，右结点的值会大于当前节点，然后一波遍历：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xquery">var isValidBST = <span class="hljs-keyword">function</span><span class="hljs-built_in">(root</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">!root</span>) <span class="hljs-keyword">return</span><span class="hljs-built_in"> true</span><br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">(root</span>.left &amp;&amp;<span class="hljs-built_in"> root</span>.left.val &gt;<span class="hljs-built_in"> root</span>.val) &#123;<br>    <span class="hljs-keyword">return</span><span class="hljs-built_in"> false</span><br>  &#125;<br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">(root</span>.right &amp;&amp;<span class="hljs-built_in"> root</span>.right.val &lt;<span class="hljs-built_in"> root</span>.val) &#123;<br>    <span class="hljs-keyword">return</span><span class="hljs-built_in"> false</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> isValidBST<span class="hljs-built_in">(root</span>.left) &amp;&amp; isValidBST<span class="hljs-built_in">(root</span>.right)<br>&#125;;<br></code></pre></td></tr></table></figure><p>看起来非常简单，主要就是判断左右节点的值和当前节点值的关系，然后一提交，原地GG。</p><p>这里的问题很简单，因为二叉搜索树的大小关系并不局限于某一个层级，它们的大小关系是存在于整个树上的，也就是顶级节点的值一定会大于所有左子节点的值，并且小于所有右子节点的值。</p><p>这是<code>isValidBST</code>方法就需要多两个参数了，用来传递给左子节点和右子节点，用来维持整个树的大小关系。并且每个层级都会变化，所以需要动态赋值。</p><p>这里的想法也是比较简单的，如果是左子树，那么它的节点值必然需要大于一个最小值，这个最小值其实就是当前节点的值，右子树同理，于时就得出了这样的一个答案👇：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xquery">var isValidBST = <span class="hljs-keyword">function</span><span class="hljs-built_in">(root</span>,<span class="hljs-built_in"> max</span> = Number.MAX_SAFE_INTEGER,<span class="hljs-built_in"> min</span> = Number.MIN_SAFE_INTEGER) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">!root</span>) <span class="hljs-keyword">return</span><span class="hljs-built_in"> true</span><br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">(root</span>.left &amp;&amp; <span class="hljs-built_in">(root</span>.left.val &gt;=<span class="hljs-built_in"> root</span>.val ||<span class="hljs-built_in"> root</span>.left.val &lt;=<span class="hljs-built_in"> min</span>)) &#123;<br>    <span class="hljs-keyword">return</span><span class="hljs-built_in"> false</span><br>  &#125;<br>  <span class="hljs-keyword">if</span> <span class="hljs-built_in">(root</span>.right &amp;&amp; <span class="hljs-built_in">(root</span>.right.val &lt;=<span class="hljs-built_in"> root</span>.val ||<span class="hljs-built_in"> root</span>.right.val &gt;=<span class="hljs-built_in"> max</span>)) &#123;<br>    <span class="hljs-keyword">return</span><span class="hljs-built_in"> false</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> isValidBST<span class="hljs-built_in">(root</span>.left,<span class="hljs-built_in"> root</span>.val,<span class="hljs-built_in"> min</span>) <br>  &amp;&amp; isValidBST<span class="hljs-built_in">(root</span>.right,<span class="hljs-built_in"> max</span>,<span class="hljs-built_in"> root</span>.val)<br>&#125;;<br></code></pre></td></tr></table></figure><p>然后再一跑，果然就成功了，但这其实并不是最好的递归解法。</p><h4 id="更好的方法（递归）"><a href="#更好的方法（递归）" class="headerlink" title="更好的方法（递归）"></a>更好的方法（递归）</h4><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xquery">var isValidBST = <span class="hljs-keyword">function</span><span class="hljs-built_in">(root</span>) &#123;<br>  <span class="hljs-keyword">function</span> checkNode(<span class="hljs-type">node</span>,<span class="hljs-built_in"> max</span>,<span class="hljs-built_in"> min</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-type">node</span>) <span class="hljs-keyword">return</span><span class="hljs-built_in"> true</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-type">node</span>.val &lt;=<span class="hljs-built_in"> min</span> || <span class="hljs-type">node</span>.val &gt;=<span class="hljs-built_in"> max</span>) <span class="hljs-keyword">return</span><span class="hljs-built_in"> false</span><br>    <span class="hljs-keyword">return</span> checkNode(<span class="hljs-type">node</span>.left, <span class="hljs-type">node</span>.val,<span class="hljs-built_in"> min</span>) &amp;&amp; checkNode(<span class="hljs-type">node</span>.right,<span class="hljs-built_in"> max</span>, <span class="hljs-type">node</span>.val)<br>  &#125;<br>  <span class="hljs-keyword">return</span> checkNode<span class="hljs-built_in">(root</span>, Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER)<br>&#125;;<br></code></pre></td></tr></table></figure><p>在笔者自己的答案中，判断的是当前节点左子树的值和右子树的值，其实这样有点复杂了。</p><p>这里只需要判断当前节点值和<code>max</code>、<code>min</code>的关系即可，当前节点的值必然要大于最小值，小于最大值，否则就无法维持整个树的大小关系。</p><p><code>max</code>和<code>min</code>的赋值也很简单，初始化很简单，因为是顶级节点，所以没有限制，只需要传入<code>JavaScript</code>所接受的最大值和最小值即可。</p><p>之后每次遍历时，如果是左子树，那么最大值就是当前节点的值，最小值不用管，继续使用<code>JavaScript</code>中的最小数字即可；如果是右子树，那么最大值不用管，最小值就是当前节点的值。</p><p>想写出这个答案需要对二叉搜索树的理解十分透彻才可以，否则只能写出像笔者一样的答案，虽然写出来了，但依然有点冗余，理解得不够透彻。</p><p>PS：这里还可以将代码浓缩为一行。</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xquery">var isValidBST = <span class="hljs-keyword">function</span><span class="hljs-built_in">(root</span>,<span class="hljs-built_in"> max</span> = Number.MAX_SAFE_INTEGER,<span class="hljs-built_in"> min</span> = Number.MIN_SAFE_INTEGER) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">!root</span> ||<span class="hljs-built_in"> root</span>.val &lt;<span class="hljs-built_in"> max</span> &amp;&amp;<span class="hljs-built_in"> root</span>.val &gt;<span class="hljs-built_in"> min</span> &amp;&amp; isValidBST<span class="hljs-built_in">(root</span>.left,<span class="hljs-built_in"> root</span>.val,<span class="hljs-built_in"> min</span>) &amp;&amp; isValidBST<span class="hljs-built_in">(root</span>.right,<span class="hljs-built_in"> max</span>,<span class="hljs-built_in"> root</span>.val)<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="更好的方法（迭代）"><a href="#更好的方法（迭代）" class="headerlink" title="更好的方法（迭代）"></a>更好的方法（迭代）</h4><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xquery">var isValidBST = <span class="hljs-keyword">function</span> <span class="hljs-built_in">(root</span>) &#123;<br>  var stack = []<br>      inorder = Number.MIN_SAFE_INTEGER<br>  while (stack.length ||<span class="hljs-built_in"> root</span>) &#123;<br>    while <span class="hljs-built_in">(root</span>) &#123;<br>      stack.push<span class="hljs-built_in">(root</span>)<br>     <span class="hljs-built_in"> root</span> =<span class="hljs-built_in"> root</span>.left<br>    &#125;<br>   <span class="hljs-built_in"> root</span> = stack.pop()<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">(root</span>.val &lt;= inorder) <span class="hljs-keyword">return</span><span class="hljs-built_in"> false</span><br>    inorder =<span class="hljs-built_in"> root</span>.val<br>   <span class="hljs-built_in"> root</span> =<span class="hljs-built_in"> root</span>.right<br>  &#125;<br>  <span class="hljs-keyword">return</span><span class="hljs-built_in"> true</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>代码不长，但理解起来确实有点难度。先定义两个变量<code>stack</code>和<code>inorder</code>，<code>stack</code>用来存放节点值，<code>inorder</code>用来存放当前的数据。</p><p>这里要说到中序遍历的一个特点，那就是遍历的结果必然是从小到大，如果有一个值比前一个小，那就证明这个数不是二叉搜索树，具体逻辑可看下面一个GIF。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7edef7bad2849ccab9c32a7754fbbfa~tplv-k3u1fbpfcp-zoom-1.image" alt="fig1"></p><p>回归正题，确定两个变量后就开始遍历了，首先确定<code>stack</code>并不是空数组，并且<code>root</code>不为<code>null</code>，否则代表遍历已经结束了。之后遍历<code>root</code>，将<code>root</code>拆开，拿到其所有的左节点，存放到<code>stack</code>中。</p><p>之后再从<code>stack</code>中拿出存储的节点信息，判断当前节点的<code>val</code>是不是大于<code>inorder</code>，如果不是直接返回<code>false</code>，否则将<code>val</code>赋值给<code>inorder</code>，再拿到右节点，开始新一轮的遍历。</p><p>如此，遍历完成后就可以得出结果。</p><p>这里真的是很难理解，反正笔者是想了得了半个多小时才理解，可能是比较愚钝吧，好好想想，总是可以理解的。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前端刷题路-Day8</title>
    <link href="/rexkentzheng/2021/04/06/%E5%89%8D%E7%AB%AF%E5%88%B7%E9%A2%98%E8%B7%AF-Day8/"/>
    <url>/rexkentzheng/2021/04/06/%E5%89%8D%E7%AB%AF%E5%88%B7%E9%A2%98%E8%B7%AF-Day8/</url>
    
    <content type="html"><![CDATA[<h3 id="三数之和（题号15）"><a href="#三数之和（题号15）" class="headerlink" title="三数之和（题号15）"></a>三数之和（题号15）</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给你一个包含 n 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <code>a</code>，<code>b</code>，<code>c</code> ，使得 <code>a + b + c = 0</code> ？请你找出所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p>示例 1：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-1</span>,0,1,2,<span class="hljs-string">-1</span>,<span class="hljs-string">-4</span>]<br>输出：[[<span class="hljs-string">-1</span>,<span class="hljs-string">-1</span>,2],[<span class="hljs-string">-1</span>,0,1]]<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[0]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>0 &lt;= nums.length &lt;= 3000</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li></ul><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><a href="https://leetcode-cn.com/problems/3sum/">https://leetcode-cn.com/problems/3sum/</a></p><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>这题说实话，自己想了半天也没想出来，只想到了最暴力的一种解法，更好的答案完全没有想法，后来看了课才勉勉强强了解了左右指针的解法，这种问题感觉只有看过才会解答啊，否则正常情况下谁没事会想到这种解决方案。</p><p>解决方法也很简单：首先将数组进行排序，从小到大和从大到小都是可以的，就是后面的操作会有些许不同，但是问题不大，这里是从小到大排序。</p><p>老规矩，先是判断数据是否是正常的数据，如果不是直接返回空数组</p><p>之后循环数组，首先，如果循环到的数字大于0，那么意味着后续永远不会有想匹配的两个数字相加为0，因为数组是从小到大排列的，后面的数只会和0相等或者大于0</p><p>之后如果当前的<code>i</code>和下一个<code>i</code>的值是一样的，那么跳过这次循环，为了去重</p><p>之后就是拿到<code>i</code>后面的左指针<code>L</code>和右指针<code>R</code>，这块就没啥可说的了，就一直挪动指针呗，直到找到合适的值为止，如果没有就进入到下一次循环当中</p><h4 id="自己的答案"><a href="#自己的答案" class="headerlink" title="自己的答案"></a>自己的答案</h4><p>无</p><h4 id="更好的解答"><a href="#更好的解答" class="headerlink" title="更好的解答"></a>更好的解答</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs awk">var threeSum = <span class="hljs-keyword">function</span>(nums) &#123;<br>  <span class="hljs-regexp">//</span> 数组长度不满足条件直接返回<br>  <span class="hljs-keyword">if</span> (!nums || nums.length &lt; <span class="hljs-number">3</span>) return []<br>  <span class="hljs-regexp">//</span> 数组排序<br>  nums.sort((a, b) =&gt; a- b)<br>  <span class="hljs-regexp">//</span> 最后的结果放这里<br>  var res = []<br>      len = nums.length<br>  <span class="hljs-regexp">//</span> 开始循环<br>  <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>    <span class="hljs-regexp">//</span> 如果当前元素大于<span class="hljs-number">0</span>，证明后续元素的和永远不可能为<span class="hljs-number">0</span>，直接返回<br>    <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span><br>    <span class="hljs-regexp">//</span> 如果当前元素和上一位元素相同，跳过这次循环<br>    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] === nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span><br>    <span class="hljs-regexp">//</span> 定义左右指针<br>    var L = i + <span class="hljs-number">1</span><br>        R = len - <span class="hljs-number">1</span><br>    <span class="hljs-regexp">//</span> 开始移动指针<br>    <span class="hljs-keyword">while</span> (L &lt; R) &#123;<br>      var sum = nums[i] + nums[L] + nums[R]<br>      <span class="hljs-keyword">if</span> (sum === <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-regexp">//</span> 如果和为<span class="hljs-number">0</span>，满足条件，添加进结果数组<br>        res.push([nums[i], nums[L], nums[R]])<br>        <span class="hljs-regexp">//</span> 如果左右指针和前后的值相同，跳过该值<br>        <span class="hljs-keyword">while</span> (nums[R] === nums[R - <span class="hljs-number">1</span>]) R--<br>        <span class="hljs-keyword">while</span> (nums[L] === nums[L + <span class="hljs-number">1</span>]) L++<br>        <span class="hljs-regexp">//</span> 正常移动左右指针<br>        L++<br>        R--<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-regexp">//</span> 值太大移动右指针<br>        R--<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-regexp">//</span> 值太小移动左指针<br>        L++<br>      &#125;<br>    &#125;<br>  &#125;<br>  return res<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端刷题路-Day7</title>
    <link href="/rexkentzheng/2021/03/31/%E5%89%8D%E7%AB%AF%E5%88%B7%E9%A2%98%E8%B7%AF-Day7/"/>
    <url>/rexkentzheng/2021/03/31/%E5%89%8D%E7%AB%AF%E5%88%B7%E9%A2%98%E8%B7%AF-Day7/</url>
    
    <content type="html"><![CDATA[<h3 id="有效的字母异位词（题号242）"><a href="#有效的字母异位词（题号242）" class="headerlink" title="有效的字母异位词（题号242）"></a>有效的字母异位词（题号242）</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给定两个字符串 <code>s</code>和 <code>t</code> ，编写一个函数来判断 <code>t</code> 是否是 <code>s</code> 的字母异位词。</p><p>示例 1:</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;anagram&quot;</span>, <span class="hljs-attr">t</span> = <span class="hljs-string">&quot;nagaram&quot;</span><br>输出: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入: <span class="hljs-attr">s</span> = <span class="hljs-string">&quot;rat&quot;</span>, <span class="hljs-attr">t</span> = <span class="hljs-string">&quot;car&quot;</span><br>输出: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>说明:<br>你可以假设字符串只包含小写字母。</p><p>进阶:<br>如果输入字符串包含 <code>unicode</code> 字符怎么办？你能否调整你的解法来应对这种情况？</p><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><a href="https://leetcode-cn.com/problems/valid-anagram/">https://leetcode-cn.com/problems/valid-anagram/</a></p><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>这题本来只想到了用<code>Map</code>或者对象来进行操作，想法比较简单，这里不多做赘述。那么剩下的一种方法就是给两个字符串进行排序，之后比较排序结果是否相等就好，这种方法比较简单，但是性能不好，并不推荐。</p><h4 id="自己的答案（对象）"><a href="#自己的答案（对象）" class="headerlink" title="自己的答案（对象）"></a>自己的答案（对象）</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> isAnagram = function(s, t) &#123;<br>  <span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> Map()<br>  <span class="hljs-keyword">var</span> sArr = s.split(<span class="hljs-string">&#x27;&#x27;</span>)<br>  <span class="hljs-keyword">var</span> tArr = t.split(<span class="hljs-string">&#x27;&#x27;</span>)<br>  <span class="hljs-keyword">if</span> (sArr.length !== tArr.length) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>; index &lt; sArr.length; index++) &#123;<br>    <span class="hljs-keyword">const</span> item = sArr[index];<br>    <span class="hljs-keyword">if</span> (!obj.has(item)) &#123;<br>      obj.<span class="hljs-keyword">set</span>(item, <span class="hljs-number">1</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      obj.<span class="hljs-keyword">set</span>(item, obj.<span class="hljs-keyword">get</span>(item) + <span class="hljs-number">1</span>)<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>; index &lt; tArr.length; index++) &#123;<br>    <span class="hljs-keyword">const</span> item = tArr[index];<br>    <span class="hljs-keyword">if</span> (!obj.has(item)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">var</span> <span class="hljs-keyword">value</span> = obj.<span class="hljs-keyword">get</span>(item)<br>      <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">value</span>) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>          obj.delete(item)<br>          <span class="hljs-keyword">break</span>    <br>        <span class="hljs-literal">default</span>:<br>          obj.<span class="hljs-keyword">set</span>(item, obj.<span class="hljs-keyword">get</span>(item) - <span class="hljs-number">1</span>)<br>          <span class="hljs-keyword">break</span><br>      &#125;      <br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (obj.size === <span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>这里用对象或者<code>Map</code>都可以，性能上都细微差异</p><h4 id="自己的答案（排序两次）"><a href="#自己的答案（排序两次）" class="headerlink" title="自己的答案（排序两次）"></a>自己的答案（排序两次）</h4><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs processing">var isAnagram = function(s, t) &#123;<br>  <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-built_in">sort</span>().<span class="hljs-built_in">join</span>(<span class="hljs-string">&#x27;&#x27;</span>) === t.<span class="hljs-built_in">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-built_in">sort</span>().<span class="hljs-built_in">join</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br>&#125;;<br></code></pre></td></tr></table></figure><p>这就没啥可以说都，一行代码搞定，用<code>toString()</code>也可以都。</p><h4 id="更好都答案"><a href="#更好都答案" class="headerlink" title="更好都答案"></a>更好都答案</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">var isAnagram = <span class="hljs-keyword">function</span>(s, t) &#123;<br>    <span class="hljs-keyword">return</span> s.length === t.length &amp;&amp; <span class="hljs-keyword">Array</span>.<span class="hljs-keyword">from</span>(<span class="hljs-keyword">Array</span>.<span class="hljs-keyword">from</span>(s).reduce((h, v, i) =&gt; (h.<span class="hljs-keyword">set</span>(v, (h.<span class="hljs-keyword">get</span>(v) || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>), h.<span class="hljs-keyword">set</span>(t[i], (h.<span class="hljs-keyword">get</span>(t[i]) || <span class="hljs-number">0</span>) - <span class="hljs-number">1</span>), h), <span class="hljs-built_in">new</span> Map).<span class="hljs-keyword">values</span>()).every(v =&gt; !v)<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>这里就是用了<code>reduce</code>，看上去高档一些</p><h3 id="两数之和（题号1）"><a href="#两数之和（题号1）" class="headerlink" title="两数之和（题号1）"></a>两数之和（题号1）</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> 的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p>你可以按任意顺序返回答案。</p><p>示例 1：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,7,11,15]</span>, target = 9<br>输出：<span class="hljs-comment">[0,1]</span><br>解释：因为 nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> == 9 ，返回 <span class="hljs-comment">[0, 1]</span> 。<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：nums = <span class="hljs-selector-attr">[3,2,4]</span>, target = <span class="hljs-number">6</span><br>输出：<span class="hljs-selector-attr">[1,2]</span><br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">输入：nums = <span class="hljs-selector-attr">[3,3]</span>, target = <span class="hljs-number">6</span><br>输出：<span class="hljs-selector-attr">[0,1]</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>2 &lt;= nums.length &lt;= 103</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li><li>只会存在一个有效答案</li></ul><h4 id="链接-1"><a href="#链接-1" class="headerlink" title="链接"></a>链接</h4><p><a href="https://leetcode-cn.com/problems/two-sum/">https://leetcode-cn.com/problems/two-sum/</a></p><h4 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h4><p>这没啥可解释都，看代码即可</p><h4 id="自己的答案"><a href="#自己的答案" class="headerlink" title="自己的答案"></a>自己的答案</h4><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;number[]&#125; nums</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;number&#125; target</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;number[]&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> twoSum = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(nums, target)</span> </span>&#123;<br>  <span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> Map()<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>; index &lt; nums.length; index++) &#123;<br>    <span class="hljs-keyword">var</span> item = nums[index];<br>    <span class="hljs-keyword">if</span> (obj.has(item)) &#123;<br>      <span class="hljs-keyword">return</span> [obj.get(item), index]<br>    &#125;<br>    obj.set(target - item, index)<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端刷题路-Day6</title>
    <link href="/rexkentzheng/2021/03/30/%E5%89%8D%E7%AB%AF%E5%88%B7%E9%A2%98%E8%B7%AF-Day6/"/>
    <url>/rexkentzheng/2021/03/30/%E5%89%8D%E7%AB%AF%E5%88%B7%E9%A2%98%E8%B7%AF-Day6/</url>
    
    <content type="html"><![CDATA[<h3 id="滑动窗口最大值（题号239）"><a href="#滑动窗口最大值（题号239）" class="headerlink" title="滑动窗口最大值（题号239）"></a>滑动窗口最大值（题号239）</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值。</p><p>示例 1：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [1,3,<span class="hljs-string">-1</span>,<span class="hljs-string">-3</span>,5,3,6,7], k = 3  <br>输出：[3,3,5,5,6,7]  <br>解释：  <br>滑动窗口的位置                最大值<br><br>---------------               -----<br><br>[1  3  <span class="hljs-string">-1</span>] <span class="hljs-string">-3</span>  5  3  6  7       3  <br> 1 [3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>] 5  3  6  7       3  <br> 1  3 [<span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>  5] 3  6  7       5  <br> 1  3  <span class="hljs-string">-1</span> [<span class="hljs-string">-3</span>  5  3] 6  7       5  <br> 1  3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span> [5  3  6] 7       6  <br> 1  3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>  5 [3  6  7]      7  <br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1]</span>, k = 1<br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,-1]</span>, k = 1<br>输出：<span class="hljs-comment">[1,-1]</span><br></code></pre></td></tr></table></figure><p>示例 4：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[9,11]</span>, k = 2<br>输出：<span class="hljs-comment">[11]</span><br></code></pre></td></tr></table></figure><p>示例 5：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[4,-2]</span>, k = 2<br>输出：<span class="hljs-comment">[4]</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 105</code> </li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>1 &lt;= k &lt;= nums.length</code>  </li></ul><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><a href="https://leetcode-cn.com/problems/sliding-window-maximum/">https://leetcode-cn.com/problems/sliding-window-maximum/</a></p><h4 id="自己的解法"><a href="#自己的解法" class="headerlink" title="自己的解法"></a>自己的解法</h4><p>无 </p><p>原因很简单，不是因为自己写不出来，而是因为这题考的是极限状态，<code>nums</code>可能会有很多，<code>k</code>值也可能会很大，有5000，那么此时如果对数组进行取最大值操作则有可能导致超出时间显示，下面这种方法在数据量少的时候是好用的，但是因为其计算时间过长，导致在数据量大的时候就会导致问题。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">k</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> maxSlidingWindow = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, k</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> res = []<br>  <span class="hljs-keyword">var</span> <span class="hljs-built_in">window</span> = []<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>; index &lt; nums.length; index++) &#123;<br>    <span class="hljs-keyword">var</span> item = nums[index]<br>    <span class="hljs-built_in">window</span>.push(item)<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.length &gt; k) &#123;<br>      <span class="hljs-built_in">window</span>.shift()<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.length &gt;= k) &#123;<br>      res.push(<span class="hljs-built_in">Math</span>.max(...window))<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="更好的答案1"><a href="#更好的答案1" class="headerlink" title="更好的答案1"></a>更好的答案1</h4><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sas"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @param &#123;number[]&#125; nums</span><br><span class="hljs-comment"> * @param &#123;number&#125; k</span><br><span class="hljs-comment"> * @return &#123;number[]&#125;</span><br><span class="hljs-comment"> */</span><br>var maxSlidingWindow = functi<span class="hljs-meta">on(</span>nums, k) &#123;<br>  var <span class="hljs-meta">window</span> = []<br>  var res = []<br>  for (let <span class="hljs-meta">index</span> = 0; <span class="hljs-meta">index</span> &lt; nums.<span class="hljs-meta">length</span> ; <span class="hljs-meta">index</span>++) &#123;<br>    <span class="hljs-meta">if</span> (<span class="hljs-meta">index</span> - k &gt;= <span class="hljs-meta">window</span>[0] <span class="hljs-variable">&amp;&amp;</span> <span class="hljs-meta">index</span> + 1 &gt; k) &#123;<br>      <span class="hljs-meta">window</span>.shift()<br>    &#125;<br>    <span class="hljs-meta">while</span> (<span class="hljs-meta">window</span>.<span class="hljs-meta">length</span> !== 0 <span class="hljs-variable">&amp;&amp;</span> nums[<span class="hljs-meta">window</span>[<span class="hljs-meta">window</span>.<span class="hljs-meta">length</span> - 1]] &lt;= nums[<span class="hljs-meta">index</span>]) &#123;<br>      <span class="hljs-meta">window</span>.pop()<br>    &#125;<br>    <span class="hljs-meta">window</span>.push(<span class="hljs-meta">index</span>)<br>    <span class="hljs-meta">if</span> (<span class="hljs-meta">index</span> &gt;= k - 1) &#123;<br>      res.push(nums[<span class="hljs-meta">window</span>[0]])<br>    &#125;<br>  &#125;<br>  <span class="hljs-meta">return</span> res<br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="更好的答案2"><a href="#更好的答案2" class="headerlink" title="更好的答案2"></a>更好的答案2</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">var maxSlidingWindow = <span class="hljs-keyword">function</span>(nums, k) &#123;<br>    <span class="hljs-keyword">let</span> n = nums.length, p = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Int16Array(<span class="hljs-params">n</span>)</span>, s = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Int16Array(<span class="hljs-params">n</span>)</span>, r = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Int16Array(<span class="hljs-params">n</span> - <span class="hljs-params">k</span> + 1)</span>, i = n, j = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> (i--) &#123;<br>        p<span class="hljs-literal">[<span class="hljs-operator">++</span><span class="hljs-identifier">j</span>]</span> = j % k ? <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(p<span class="hljs-literal">[<span class="hljs-identifier">j</span> - <span class="hljs-number">1</span>]</span>, nums<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>) : nums<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span><br>        s<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>   = i % k ? <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(s<span class="hljs-literal">[<span class="hljs-identifier">i</span> + <span class="hljs-number">1</span>]</span>, nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>) : nums<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span><br>    &#125;<br>    <span class="hljs-keyword">while</span> (i++ &lt; n - k) r<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(s<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>, p<span class="hljs-literal">[<span class="hljs-identifier">i</span> + <span class="hljs-identifier">k</span> - <span class="hljs-number">1</span>]</span>)<br>    return r<br>&#125;; <br><br></code></pre></td></tr></table></figure><h4 id="更好的答案3-N"><a href="#更好的答案3-N" class="headerlink" title="更好的答案3~N"></a>更好的答案3~N</h4><p><a href="https://leetcode-cn.com/problems/sliding-window-maximum/solution/ji-shu-shuang-duan-fen-kuai-you-xian-5xi-87ud/">https://leetcode-cn.com/problems/sliding-window-maximum/solution/ji-shu-shuang-duan-fen-kuai-you-xian-5xi-87ud/</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前端刷题路-Day5</title>
    <link href="/rexkentzheng/2021/03/30/%E5%89%8D%E7%AB%AF%E5%88%B7%E9%A2%98%E8%B7%AF-Day5/"/>
    <url>/rexkentzheng/2021/03/30/%E5%89%8D%E7%AB%AF%E5%88%B7%E9%A2%98%E8%B7%AF-Day5/</url>
    
    <content type="html"><![CDATA[<h3 id="用栈实现队列（题号232）"><a href="#用栈实现队列（题号232）" class="headerlink" title="用栈实现队列（题号232）"></a>用栈实现队列（题号232）</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列的支持的所有操作（<code>push、pop、peek、empty</code>）：</p><p>实现<code>MyQueue</code>类：</p><ul><li><code>void push(int x)</code>将元素<code>x</code>推到队列的末尾</li><li><code>int pop()</code>从队列的开头移除并返回元素</li><li><code>int peek()</code> 返回队列开头的元素</li><li><code>boolean empty()</code>如果队列为空，返回<code>true</code>；否则，返回<code>false</code></li></ul><p>说明：</p><p>你只能使用标准的栈操作 —— 也就是只有<code>push to top</code>, <code>peek/pop from top</code>, <code>size</code>, 和 <code>is empty</code> 操作是合法的。<br>你所使用的语言也许不支持栈。你可以使用 <code>list</code> 或者 <code>deque</code>（双端队列）来模拟一个栈，只要是标准的栈操作即可。 </p><p>进阶：</p><p>你能否实现每个操作均摊时间复杂度为 <code>O(1)</code> 的队列？换句话说，执行 <code>n</code> 个操作的总时间复杂度为 <code>O(n)</code> ，即使其中一个操作可能花费较长时间。 </p><p>示例：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs gradle">输入：<br>[<span class="hljs-string">&quot;MyQueue&quot;</span>, <span class="hljs-string">&quot;push&quot;</span>, <span class="hljs-string">&quot;push&quot;</span>, <span class="hljs-string">&quot;peek&quot;</span>, <span class="hljs-string">&quot;pop&quot;</span>, <span class="hljs-string">&quot;empty&quot;</span>]<br>[[], [<span class="hljs-number">1</span>], [<span class="hljs-number">2</span>], [], [], []]<br>输出：<br>[<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-keyword">false</span>]<br><br>解释：<br>MyQueue myQueue = <span class="hljs-keyword">new</span> MyQueue();<br>myQueue.<span class="hljs-keyword">push</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// queue is: [1]</span><br>myQueue.<span class="hljs-keyword">push</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// queue is: [1, 2] (leftmost is front of the queue)</span><br>myQueue.peek(); <span class="hljs-comment">// return 1</span><br>myQueue.<span class="hljs-keyword">pop</span>(); <span class="hljs-comment">// return 1, queue is [2]</span><br>myQueue.empty(); <span class="hljs-comment">// return false</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= x &lt;= 9</code></li><li>最多调用 <code>100</code> 次 <code>push</code>、<code>pop</code>、<code>peek</code> 和 <code>empty</code></li><li>假设所有操作都是有效的 （例如，一个空的队列不会调用 <code>pop</code> 或者 <code>peek</code> 操作）</li></ul><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks/">https://leetcode-cn.com/problems/implement-queue-using-stacks/</a></p><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>这没啥可解释的，因为数组都集成了，主要就是队列的定义，先进先出，后进后出，只要清楚这个概念，直接调用时数组的原生方法即可</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Initialize your data structure here.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> MyQueue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">this</span>.arr = []<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Push element x to the back of queue. </span><br><span class="hljs-comment"> * @param &#123;number&#125; x</span><br><span class="hljs-comment"> * @return &#123;void&#125;</span><br><span class="hljs-comment"> */</span><br>MyQueue.prototype.push = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>&#123;<br>  <span class="hljs-keyword">this</span>.arr.push(x)<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Removes the element from in front of queue and returns that element.</span><br><span class="hljs-comment"> * @return &#123;number&#125;</span><br><span class="hljs-comment"> */</span><br>MyQueue.prototype.pop = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// console.log(this.arr.pop())</span><br>  <span class="hljs-comment">// console.log(this.arr)</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.arr.shift()<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Get the front element.</span><br><span class="hljs-comment"> * @return &#123;number&#125;</span><br><span class="hljs-comment"> */</span><br>MyQueue.prototype.peek = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.arr.length &gt; <span class="hljs-number">1</span> ? <span class="hljs-keyword">this</span>.arr[<span class="hljs-number">0</span>] : <span class="hljs-literal">null</span><br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns whether the queue is empty.</span><br><span class="hljs-comment"> * @return &#123;boolean&#125;</span><br><span class="hljs-comment"> */</span><br>MyQueue.prototype.empty = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.arr)<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.arr.length === <span class="hljs-number">0</span><br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * var obj = new MyQueue()</span><br><span class="hljs-comment"> * obj.push(x)</span><br><span class="hljs-comment"> * var param_2 = obj.pop()</span><br><span class="hljs-comment"> * var param_3 = obj.peek()</span><br><span class="hljs-comment"> * var param_4 = obj.empty()</span><br><span class="hljs-comment"> */</span><br><br></code></pre></td></tr></table></figure><h3 id="用队列实现栈（题号225）"><a href="#用队列实现栈（题号225）" class="headerlink" title="用队列实现栈（题号225）"></a>用队列实现栈（题号225）</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通队列的全部四种操作（<code>push</code>、<code>top</code>、<code>pop</code> 和 <code>empty</code>）。</p><p>实现 <code>MyStack</code> 类：</p><ul><li><code>void push(int x)</code> 将元素 <code>x</code> 压入栈顶。</li><li><code>int pop()</code> 移除并返回栈顶元素。</li><li><code>int top()</code> 返回栈顶元素。</li><li><code>boolean empty()</code> 如果栈是空的，返回 <code>true</code> ；否则，返回 <code>false</code> 。 </li></ul><p>注意：</p><p>你只能使用队列的基本操作 —— 也就是 <code>push to back</code>、<code>peek/pop from front</code>、<code>size</code> 和 <code>is empty</code> 这些操作。<br>你所使用的语言也许不支持队列。 你可以使用 <code>list</code> （列表）或者 <code>deque</code>（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。 </p><p>示例：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs gradle">输入：<br>[<span class="hljs-string">&quot;MyStack&quot;</span>, <span class="hljs-string">&quot;push&quot;</span>, <span class="hljs-string">&quot;push&quot;</span>, <span class="hljs-string">&quot;top&quot;</span>, <span class="hljs-string">&quot;pop&quot;</span>, <span class="hljs-string">&quot;empty&quot;</span>]<br>[[], [<span class="hljs-number">1</span>], [<span class="hljs-number">2</span>], [], [], []]<br>输出：<br>[<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-keyword">false</span>]<br><br>解释：<br>MyStack myStack = <span class="hljs-keyword">new</span> MyStack();<br>myStack.<span class="hljs-keyword">push</span>(<span class="hljs-number">1</span>);<br>myStack.<span class="hljs-keyword">push</span>(<span class="hljs-number">2</span>);<br>myStack.top(); <span class="hljs-comment">// 返回 2</span><br>myStack.<span class="hljs-keyword">pop</span>(); <span class="hljs-comment">// 返回 2</span><br>myStack.empty(); <span class="hljs-comment">// 返回 False</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= x &lt;= 9</code></li><li>最多调用100 次 <code>push</code>、<code>pop</code>、<code>top</code> 和 <code>empty</code></li><li>每次调用 <code>pop</code> 和 <code>top</code> 都保证栈不为空 </li></ul><p>进阶：你能否实现每种操作的均摊时间复杂度为 <code>O(1)</code> 的栈？换句话说，执行 <code>n</code> 个操作的总时间复杂度 <code>O(n)</code> ，尽管其中某个操作可能需要比其他操作更长的时间。你可以使用两个以上的队列。</p><h4 id="链接-1"><a href="#链接-1" class="headerlink" title="链接"></a>链接</h4><p><a href="https://leetcode-cn.com/problems/implement-stack-using-queues/">https://leetcode-cn.com/problems/implement-stack-using-queues/</a></p><h4 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h4><p>这没啥可解释的，因为数组都集成了，主要就是栈的定义，先进后出，后入先出，只要清楚这个概念，直接调用时数组的原生方法即可。</p><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Initialize your data structure here.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> MyStack = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  this.arr = []<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Push element x onto stack. </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &#123;number&#125; x</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;void&#125;</span><br><span class="hljs-comment"> */</span><br>MyStack.prototype.push = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>&#123;<br>  this.arr.push(x)<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Removes the element on top of the stack and returns that element.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;number&#125;</span><br><span class="hljs-comment"> */</span><br>MyStack.prototype.pop = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> this.arr.pop()<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Get the top element.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;number&#125;</span><br><span class="hljs-comment"> */</span><br>MyStack.prototype.top = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br> <span class="hljs-keyword">return</span> this.arr[this.arr.length - <span class="hljs-number">1</span>]<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns whether the stack is empty.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;boolean&#125;</span><br><span class="hljs-comment"> */</span><br>MyStack.prototype.<span class="hljs-keyword">empty</span> = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> this.arr.length === <span class="hljs-number">0</span><br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * var obj = new MyStack()</span><br><span class="hljs-comment"> * obj.push(x)</span><br><span class="hljs-comment"> * var param_2 = obj.pop()</span><br><span class="hljs-comment"> * var param_3 = obj.top()</span><br><span class="hljs-comment"> * var param_4 = obj.empty()</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前端刷题路-Day4</title>
    <link href="/rexkentzheng/2021/03/24/%E5%89%8D%E7%AB%AF%E5%88%B7%E9%A2%98%E8%B7%AF-Day4/"/>
    <url>/rexkentzheng/2021/03/24/%E5%89%8D%E7%AB%AF%E5%88%B7%E9%A2%98%E8%B7%AF-Day4/</url>
    
    <content type="html"><![CDATA[<h3 id="两两交换链表中的节点（题号24）"><a href="#两两交换链表中的节点（题号24）" class="headerlink" title="两两交换链表中的节点（题号24）"></a>两两交换链表中的节点（题号24）</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p>示例 1：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：head = [<span class="hljs-number">1,2,3,4</span>]<br>输出：[<span class="hljs-number">2,1,4,3</span>]<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1]</span><br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>链表中节点的数目在范围 [0, 100] 内</li><li>0 &lt;= Node.val &lt;= 100</li></ul><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">https://leetcode-cn.com/problems/swap-nodes-in-pairs/</a></p><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>这一题还好，根据昨天写的反转链表，使用了递归的方法来进行操作，没啥可说的，主要是更好的答案，这里采用的是迭代，反正我是没太看懂，以后有时间可以看看</p><h4 id="自己的解法"><a href="#自己的解法" class="headerlink" title="自己的解法"></a>自己的解法</h4><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xquery">var swapPairs = <span class="hljs-keyword">function</span><span class="hljs-built_in">(head</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">!head</span> || <span class="hljs-built_in">!head</span>.<span class="hljs-keyword">next</span>) <span class="hljs-keyword">return</span><span class="hljs-built_in"> head</span><br>  var dummy =<span class="hljs-built_in"> head</span>.<span class="hljs-keyword">next</span><br>  <span class="hljs-keyword">if</span> (dummy.<span class="hljs-keyword">next</span>) dummy.<span class="hljs-keyword">next</span> = swapPairs(dummy.<span class="hljs-keyword">next</span>)<br> <span class="hljs-built_in"> head</span>.<span class="hljs-keyword">next</span> = dummy.<span class="hljs-keyword">next</span><br>  dummy.<span class="hljs-keyword">next</span> =<span class="hljs-built_in"> head</span><br> <span class="hljs-built_in"> head</span> = dummy<br>  <span class="hljs-keyword">return</span><span class="hljs-built_in"> head</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="更好的答案"><a href="#更好的答案" class="headerlink" title="更好的答案"></a>更好的答案</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs awk">var swapPairs = <span class="hljs-keyword">function</span>(head) &#123;<br>  <span class="hljs-regexp">//</span> <span class="hljs-number">1</span>. 确认 head 大于等于两个，否则返回;<br>  <span class="hljs-keyword">if</span> (!head || !head.<span class="hljs-keyword">next</span>) return head;<br>  <span class="hljs-regexp">//</span> <span class="hljs-number">2</span>. 新建链表哨兵头并创建指针curr；<br>  let res = new ListNode(null);<br>  res.<span class="hljs-keyword">next</span> = head;<br>  let prev = res;<br>  console.log(prev)<br>  <span class="hljs-regexp">//</span> <span class="hljs-number">3</span>. 循环开始<br>  <span class="hljs-regexp">//</span>    <span class="hljs-number">3.1</span> 走两步，存为fst, snd;<br>  <span class="hljs-regexp">//</span>    <span class="hljs-number">3.2</span> 哨兵-&gt;snd, fst-&gt;snd.<span class="hljs-keyword">next</span>, snd-&gt;fst;<br>  <span class="hljs-regexp">//</span>    <span class="hljs-number">3.3</span> 推进 curr = curr.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;<br>  <span class="hljs-keyword">while</span> (prev.<span class="hljs-keyword">next</span> &amp;&amp; prev.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>) &#123;<br>    let [fst, snd] = [prev.<span class="hljs-keyword">next</span>, prev.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>];<br>    [prev.<span class="hljs-keyword">next</span>, fst.<span class="hljs-keyword">next</span>, snd.<span class="hljs-keyword">next</span>] = [snd, snd.<span class="hljs-keyword">next</span>, fst];<br>    prev = prev.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span>;<br>  &#125;<br>  <span class="hljs-regexp">//</span> <span class="hljs-number">4</span>. 返回res.<span class="hljs-keyword">next</span>;<br>  return res.<span class="hljs-keyword">next</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="环形链表（题号141）"><a href="#环形链表（题号141）" class="headerlink" title="环形链表（题号141）"></a>环形链表（题号141）</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>给定一个链表，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。   为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。<br>如果 pos 是 -1，则在该链表中没有环。<br>注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。<br>如果链表中存在环，则返回 true 。 否则，返回 false 。</p><p>进阶：</p><ul><li>你能用 O(1)（即，常量）内存解决此问题吗？</li></ul><p>示例 1：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">head</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">4</span>], <span class="hljs-attr">pos</span> = <span class="hljs-number">1</span>  <br>输出：<span class="hljs-literal">true</span>  <br>解释：链表中有一个环，其尾部连接到第二个节点。 <br></code></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">head</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], <span class="hljs-attr">pos</span> = <span class="hljs-number">0</span>  <br>输出：<span class="hljs-literal">true</span>  <br>解释：链表中有一个环，其尾部连接到第一个节点。  <br></code></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">head</span> = [<span class="hljs-number">1</span>], <span class="hljs-attr">pos</span> = -<span class="hljs-number">1</span>  <br>输出：<span class="hljs-literal">false</span>  <br>解释：链表中没有环。  <br></code></pre></td></tr></table></figure><p>提示：</p><ul><li>链表中节点的数目范围是 [0, 104]</li><li>-105 &lt;= Node.val &lt;= 105</li><li>pos 为 -1 或者链表中的一个 有效索引 。</li></ul><h4 id="链接-1"><a href="#链接-1" class="headerlink" title="链接"></a>链接</h4><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/solution/jsshi-xian-si-chong-fang-fa-by-careteenl/">https://leetcode-cn.com/problems/linked-list-cycle/solution/jsshi-xian-si-chong-fang-fa-by-careteenl/</a></p><h4 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h4><p>这题首先是想到了一种诡异无比的写法，直接使用<code>JSON.stringify(head)</code>来判断，如果是循环，会报错，然后捕获错误就好，非常简单方便，就是性能堪忧，只能超过5%的人。  </p><p>第二种解法就比较正常了，使用了迭代的方法，把每个结点的<code>next</code>都存在<code>Map</code>中，之后开始循环，如果<code>Map</code>中已经存在该节点，那就证明已经循环了，直接返回<code>true</code>，碰到<code>null</code>就返回<code>false</code>。</p><p>更好的解法其实是双指针迭代，第一种是其实更多的是类似单指针的操作，简单来说就是两个人跑步，一个人先出发，另一个人后触发，如果是一个圈，那么先出发的人必然会遇到后出发的人，也就是它超过第一个人一圈的时候。</p><p>第二种更好的解法就是双指针，两个人同时出发，一个人跑的快，一个人跑得慢，是上一种方法的小优化吧，看上去更简洁，运行起来也快一丢丢。</p><h4 id="自己的解法1"><a href="#自己的解法1" class="headerlink" title="自己的解法1"></a>自己的解法1</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">var</span> hasCycleSpecial = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-built_in">JSON</span>.stringify(head)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>  &#125; <span class="hljs-keyword">catch</span>(err) &#123;<br>    <span class="hljs-keyword">return</span> !!err<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="自己的解法2"><a href="#自己的解法2" class="headerlink" title="自己的解法2"></a>自己的解法2</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">var</span> hasCycle = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">head</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!head || !head.next) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>  <span class="hljs-keyword">var</span> res = head;<br>  <span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span><br>  <span class="hljs-keyword">var</span> ans = <span class="hljs-literal">false</span><br>  <span class="hljs-keyword">while</span> (res) &#123;<br>    <span class="hljs-keyword">if</span> (obj.has(res)) &#123;<br>      ans = <span class="hljs-literal">true</span><br>      res = <span class="hljs-literal">null</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      obj.set(res, <span class="hljs-number">1</span>)<br>      res = res.next  <br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ans<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="更好的答案1"><a href="#更好的答案1" class="headerlink" title="更好的答案1"></a>更好的答案1</h4><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xquery">var hasCycle = <span class="hljs-keyword">function</span><span class="hljs-built_in">(head</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">!head</span> || <span class="hljs-built_in">!head</span>.<span class="hljs-keyword">next</span>) <span class="hljs-keyword">return</span><span class="hljs-built_in"> false</span><br>  var fast =<span class="hljs-built_in"> head</span>.<span class="hljs-keyword">next</span><br>  var slow =<span class="hljs-built_in"> head</span><br>  while (fast !== slow) &#123;<br>    <span class="hljs-keyword">if</span> (!fast || !fast.<span class="hljs-keyword">next</span>) &#123;<br>      <span class="hljs-keyword">return</span><span class="hljs-built_in"> false</span><br>    &#125;<br>    fast = fast.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span><br>    slow = slow.<span class="hljs-keyword">next</span><br>  &#125;<br>  <span class="hljs-keyword">return</span><span class="hljs-built_in"> true</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="更好的答案2"><a href="#更好的答案2" class="headerlink" title="更好的答案2"></a>更好的答案2</h4><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xquery">var hasCycle4 = <span class="hljs-keyword">function</span> <span class="hljs-built_in">(head</span>) &#123;<br>  var slow =<span class="hljs-built_in"> head</span>,<br>    fast =<span class="hljs-built_in"> head</span><br>  while (fast &amp;&amp; fast.<span class="hljs-keyword">next</span>) &#123;<br>    slow = slow.<span class="hljs-keyword">next</span><br>    fast = fast.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">next</span><br>    <span class="hljs-keyword">if</span> (slow == fast) <span class="hljs-keyword">return</span><span class="hljs-built_in"> true</span><br>  &#125;<br>  <span class="hljs-keyword">return</span><span class="hljs-built_in"> false</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前端刷题路-Day3</title>
    <link href="/rexkentzheng/2021/03/23/%E5%89%8D%E7%AB%AF%E5%88%B7%E9%A2%98%E8%B7%AF-Day3/"/>
    <url>/rexkentzheng/2021/03/23/%E5%89%8D%E7%AB%AF%E5%88%B7%E9%A2%98%E8%B7%AF-Day3/</url>
    
    <content type="html"><![CDATA[<h3 id="链表反转（题号24）"><a href="#链表反转（题号24）" class="headerlink" title="链表反转（题号24）"></a>链表反转（题号24）</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><p>示例:</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">输入: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;NULL  <br>输出: <span class="hljs-number">5</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">1</span>-&gt;NULL<br></code></pre></td></tr></table></figure><p>限制：  </p><ul><li>0 &lt;= 节点个数 &lt;= 5000</li></ul><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof">https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof</a></p><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>关于链表其实自己的理解一直都错了，根据网上的教程来看，链表的本质貌似是一个数组，数组中有一个个元素，如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml">[&#123;<br> <span class="hljs-attr">val:</span> <span class="hljs-number">1</span>,<br> <span class="hljs-attr">next:</span> <span class="hljs-number">2</span>,<br>&#125;, &#123;<br> <span class="hljs-attr">val:</span> <span class="hljs-number">2</span>,<br> <span class="hljs-attr">next:</span> <span class="hljs-number">3</span>,<br>&#125;, &#123;<br> <span class="hljs-attr">val:</span> <span class="hljs-number">3</span>,<br> <span class="hljs-attr">next:</span> <span class="hljs-literal">null</span><br>&#125;]<br></code></pre></td></tr></table></figure><p>但其实并不是，链表的本质有点类似于树的形态，它是这样的：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;val&quot;</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">&quot;next&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;val&quot;</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">&quot;next&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;val&quot;</span>: <span class="hljs-number">3</span>,<br>      <span class="hljs-attr">&quot;next&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;val&quot;</span>: <span class="hljs-number">4</span>,<br>        <span class="hljs-attr">&quot;next&quot;</span>: &#123;<br>          <span class="hljs-attr">&quot;val&quot;</span>: <span class="hljs-number">5</span>,<br>          <span class="hljs-attr">&quot;next&quot;</span>: <span class="hljs-literal">null</span><br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>每个<code>next</code>都包含着剩下所有的内容，比方说这是一个5组数据的链表，那么第一个元素的<code>next</code>包含着剩下四组的数据的所有内容，第二个元素的<code>next</code>包含着剩下三组元素的所有内容，这才是链表。</p><h4 id="自己的解法"><a href="#自己的解法" class="headerlink" title="自己的解法"></a>自己的解法</h4><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">var</span> <span class="hljs-keyword">new</span><span class="hljs-type">ReverseList</span> = <span class="hljs-function"><span class="hljs-keyword">function</span></span>(head) &#123;<br>  <span class="hljs-keyword">var</span> <span class="hljs-keyword">new</span><span class="hljs-type">List</span> = &#123;&#125;<br>  <span class="hljs-keyword">var</span> arr = []<br>  <span class="hljs-keyword">if</span> (!head) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNode</span></span>(list) &#123;<br>    <span class="hljs-keyword">if</span> (list !== <span class="hljs-literal">null</span>) &#123;<br>      arr.push(list.val)<br>      getNode(list.next)<br>    &#125;    <br>  &#125;<br>  getNode(head)<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addNode</span></span>(index) &#123;<br>    <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> &#123;<br>        val: <span class="hljs-type">arr</span>[index],<br>        next: <span class="hljs-type">addNode</span>(index - <span class="hljs-number">1</span>)<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">new</span><span class="hljs-type">List</span> = addNode(arr.length - <span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span><span class="hljs-type">List</span><br><span class="hljs-type"></span>&#125;;<br></code></pre></td></tr></table></figure><p>看看这个答案，明显就是菜鸡写的，首选定义一个方法来获取链表中所有的<code>val</code>，拿到数组后再递归写入新的链表，暨此实现反转链表的效果。</p><p>但这样做时间复杂度有O(2n)，这么高，这还是经过一些简化的代码，否则后续写入的时候又是持续的低柜，时间复杂度会更高，不过对于初学者来说这样的代码看起来十分正常。</p><h4 id="更好的答案"><a href="#更好的答案" class="headerlink" title="更好的答案"></a>更好的答案</h4><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">var</span> newReverseList = function(head) &#123;<br>  <span class="hljs-keyword">if</span> (!head || !head.<span class="hljs-keyword">next</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br>  <span class="hljs-built_in">var</span> cur = head;<br>  <span class="hljs-built_in">var</span> pre = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">while</span> (cur) &#123;<br>    <span class="hljs-built_in">var</span> <span class="hljs-keyword">next</span> = cur.<span class="hljs-keyword">next</span>;<br>    cur.<span class="hljs-keyword">next</span> = pre;<br>    pre = cur;<br>    cur = <span class="hljs-keyword">next</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> pre<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个答案一度让我无法理解，因为链表的特殊结构，这样的操作根本就看不懂了，几次尝试打印才勉强理解了。</p><p>首先，代码的<code>if</code>判断就不解释了，为了排除某些特殊情况，下面才是重点。</p><p>首先声明了两个变量，<code>cur</code>为当前的链表，<code>pre</code>为反转后的链表。</p><p>之后<code>while</code>循环<code>cur</code>变量，在循环内部，首先拿出<code>cur</code>的<code>next</code>，之后将<code>cur</code>的<code>next</code>属性赋值为<code>pre</code>。之后将<code>pre</code>赋值为改变<code>next</code>后的<code>pre</code>，最后，将<code>cur</code>赋值为其<code>next</code>属性。</p><p>之后开始循环，一层层展开<code>cur</code>，<code>pre</code>也是一层层的增加赋值，<code>pre</code>是从里到外增加，而<code>cur</code>是从外到里减少，这也正契合了链表反转的主题。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前端刷题路-Day2</title>
    <link href="/rexkentzheng/2021/03/22/%E5%89%8D%E7%AB%AF%E5%88%B7%E9%A2%98%E8%B7%AF-Day2/"/>
    <url>/rexkentzheng/2021/03/22/%E5%89%8D%E7%AB%AF%E5%88%B7%E9%A2%98%E8%B7%AF-Day2/</url>
    
    <content type="html"><![CDATA[<h3 id="罗马数字转整数（题号12）"><a href="#罗马数字转整数（题号12）" class="headerlink" title="罗马数字转整数（题号12）"></a>罗马数字转整数（题号12）</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">字符          数值<br><span class="hljs-built_in">I</span>             <span class="hljs-number">1</span><br><span class="hljs-variable">V</span>             <span class="hljs-number">5</span><br><span class="hljs-variable">X</span>             <span class="hljs-number">10</span><br><span class="hljs-variable">L</span>             <span class="hljs-number">50</span><br><span class="hljs-built_in">C</span>             <span class="hljs-number">100</span><br><span class="hljs-built_in">D</span>             <span class="hljs-number">500</span><br><span class="hljs-variable">M</span>             <span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><p>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<br>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。<br>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999   的范围内。</p><p>示例 1:<br>输入: “III”<br>输出: 3  </p><p>示例 2:<br>输入: “IV”<br>输出: 4  </p><p>示例 3:<br>输入: “IX”<br>输出: 9  </p><p>示例 4:<br>输入: “LVIII”<br>输出: 58<br>解释: L = 50, V= 5, III = 3.  </p><p>示例 5:<br>输入: “MCMXCIV”<br>输出: 1994<br>解释: M = 1000, CM = 900, XC = 90, IV = 4.  </p><p>提示：</p><blockquote><p>1 &lt;= s.length &lt;= 15<br>str仅含字符 (‘I’, ‘V’, ‘X’, ‘L’, ‘C’, ‘D’, ‘M’)<br>题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内。<br>题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。<br>IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。  </p></blockquote><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><a href="https://leetcode-cn.com/problems/roman-to-integer/">https://leetcode-cn.com/problems/roman-to-integer/</a></p><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>首先需要看好题目，这题的题目有两个重点：</p><ol><li>通常情况下，罗马数字中小的数字在大的数字的右边</li><li>一大堆特例，也就是小数出现在大数前面</li></ol><p>第二点就不用多说了，重点需要处理的地方，但是第一点也不能忘，这里的意思是除去特殊情况之外，所有的数字都是从大到小，这样一来，方法就简单很多，因为不需要讨论小数在大数前面但并非是特例的情况了。</p><h4 id="自己的答案"><a href="#自己的答案" class="headerlink" title="自己的答案"></a>自己的答案</h4><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-keyword">var</span> romanToInt = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(s)</span> </span>&#123;<br>  <span class="hljs-keyword">var</span> kvObj = &#123;<br>    <span class="hljs-string">&#x27;I&#x27;</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-string">&#x27;V&#x27;</span>: <span class="hljs-number">5</span>,<br>    <span class="hljs-string">&#x27;X&#x27;</span>: <span class="hljs-number">10</span>,<br>    <span class="hljs-string">&#x27;L&#x27;</span>: <span class="hljs-number">50</span>,<br>    <span class="hljs-string">&#x27;C&#x27;</span>: <span class="hljs-number">100</span>,<br>    <span class="hljs-string">&#x27;D&#x27;</span>: <span class="hljs-number">500</span>,<br>    <span class="hljs-string">&#x27;M&#x27;</span>: <span class="hljs-number">1000</span><br>  &#125;<br>  <span class="hljs-keyword">var</span> sArr = s.split(<span class="hljs-string">&#x27;&#x27;</span>)<br><br>  <span class="hljs-keyword">var</span> res = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; sArr.length; i++) &#123;<br>    <span class="hljs-keyword">var</span> item = kvObj[sArr[i]]<br>    <span class="hljs-keyword">if</span> (kvObj[sArr[i]] &lt; kvObj[sArr[i + <span class="hljs-number">1</span>]]) &#123;<br>      res += kvObj[sArr[i + <span class="hljs-number">1</span>]] - item<br>      i++<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      res += item<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res<br>&#125;;<br></code></pre></td></tr></table></figure><p>想法很简单，首先给定每个罗马数字对应的阿拉伯数字，做成一个对象，这里使用<code>Map</code>也是可以的。</p><p>之后将罗马数字拆分成数组，如果下一个比前一个大，那么就是特殊情况，特殊情况的规则也就是用大数减去小数的差，那么循环里面的判断就很简单了。</p><p>如果下一个数比当前的数大，那么就是特殊情况了，取其差，累加到<code>res</code>上，并且<code>i++</code>，跳过下一次循环；如果不大，那么正常累加即可。</p><p>整体逻辑比较简单，但笔者还是发现了一种更好的办法。</p><h4 id="更好的方法"><a href="#更好的方法" class="headerlink" title="更好的方法"></a>更好的方法</h4><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xquery">var romanToInt = <span class="hljs-keyword">function</span>(s) &#123;<br>  const table = &#123;<br>      <span class="hljs-string">&#x27;I&#x27;</span>: <span class="hljs-number">1</span>,<br>      <span class="hljs-string">&#x27;V&#x27;</span>: <span class="hljs-number">5</span>,<br>      <span class="hljs-string">&#x27;X&#x27;</span>: <span class="hljs-number">10</span>,<br>      <span class="hljs-string">&#x27;L&#x27;</span>: <span class="hljs-number">50</span>,<br>      <span class="hljs-string">&#x27;C&#x27;</span>: <span class="hljs-number">100</span>,<br>      <span class="hljs-string">&#x27;D&#x27;</span>: <span class="hljs-number">500</span>,<br>      <span class="hljs-string">&#x27;M&#x27;</span>: <span class="hljs-number">1000</span><br>  &#125;;<br>  <span class="hljs-keyword">let</span><span class="hljs-built_in"> sum</span> = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> pre = table[s[<span class="hljs-number">0</span>]];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; s.length; i++) &#123;<br>      <span class="hljs-keyword">let</span> cur = table[s[i]];<br>      <span class="hljs-keyword">if</span> (pre &lt; cur) &#123;<br>         <span class="hljs-built_in"> sum</span> -= pre;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-built_in"> sum</span> += pre;<br>      &#125;<br>      pre = cur;<br>  &#125;<br> <span class="hljs-built_in"> sum</span> += pre;<br>  <span class="hljs-keyword">return</span><span class="hljs-built_in"> sum</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里可以看出来，原理什么都是一样的，也就是利用一个对象来存储对应的罗马数字和阿拉伯数字的关系，然后开始循环罗马数字的数组。</p><p>重点就在循环内部，这里把当前元素和下一个元素的比较换成了当前元素和上一个元素的比较，定义了<code>pre</code>变量，如果下一个元素大于前一个元素，违背了罗马数字从大到小排序的规则，那就证明这种情况是特殊情况。</p><p>对于特殊情况的处理就是减去小的那个数，加上那个大的数，于是这里的判断就变成了简单的加减。</p><p>感觉比自己的答案逻辑上更简单一点。</p><p>不过感觉这种操作不是很好理解，仁者见仁吧。</p><p>原答案在<a href="https://leetcode-cn.com/problems/roman-to-integer/solution/ha-xi-biao-by-lxhguard-t8ad/">这里</a>，感兴趣的可以看看</p><h3 id="最长公共前缀（题号14）"><a href="#最长公共前缀（题号14）" class="headerlink" title="最长公共前缀（题号14）"></a>最长公共前缀（题号14）</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>编写一个函数来查找字符串数组中的最长公共前缀。<br>如果不存在公共前缀，返回空字符串 “”。</p><p>示例 1：<br>输入：strs = [“flower”,”flow”,”flight”]<br>输出：”fl”  </p><p>示例 2：<br>输入：strs = [“dog”,”racecar”,”car”]<br>输出：””<br>解释：输入不存在公共前缀。  </p><p>提示：  </p><blockquote><p>0 &lt;= strs.length &lt;= 200<br>0 &lt;= strs[i].length &lt;= 200<br>strs[i] 仅由小写英文字母组成  </p></blockquote><h4 id="链接-1"><a href="#链接-1" class="headerlink" title="链接"></a>链接</h4><p><a href="https://leetcode-cn.com/problems/longest-common-prefix/">https://leetcode-cn.com/problems/longest-common-prefix/</a></p><h4 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h4><p>第一眼看到这题应该就会想到答案，正常的循环即可，再遍历每个单词，提取它们的公共部分，循环到最后一个单词是结束，拿到所有单词的公共部分即可。</p><p>可这样真的是最好的办法么？显然不是，具体请看更好的方法。</p><h4 id="自己的答案（经典暴力查找）"><a href="#自己的答案（经典暴力查找）" class="headerlink" title="自己的答案（经典暴力查找）"></a>自己的答案（经典暴力查找）</h4><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs sas">var longestCommonPrefix = functi<span class="hljs-meta">on(</span>strs) &#123;<br>  var res = []<br>  for (let <span class="hljs-meta">index</span> = 0; <span class="hljs-meta">index</span> &lt; strs.<span class="hljs-meta">length</span>; <span class="hljs-meta">index</span>++) &#123;<br>    var sArr = strs[<span class="hljs-meta">index</span>].split(<span class="hljs-string">&#x27;&#x27;</span>)<br>    <span class="hljs-meta">if</span> (sArr.<span class="hljs-meta">length</span> === 0) <span class="hljs-meta">return</span> <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-meta">if</span> (<span class="hljs-meta">index</span> === 0) &#123;<br>      res = sArr<br>    &#125; <span class="hljs-meta">else</span> &#123;<br>      var temp = []<br>      for (let <span class="hljs-meta">index</span> = 0; <span class="hljs-meta">index</span> &lt; sArr.<span class="hljs-meta">length</span>; <span class="hljs-meta">index</span>++) &#123;<br>        <span class="hljs-meta">if</span> (sArr[<span class="hljs-meta">index</span>] === res[<span class="hljs-meta">index</span>]) &#123;<br>          temp.push(sArr[<span class="hljs-meta">index</span>])<br>          <span class="hljs-meta">if</span> (<span class="hljs-meta">index</span> + 1 === sArr.<span class="hljs-meta">length</span>) res = temp<br>        &#125; <span class="hljs-meta">else</span> &#123;<br>          res = temp;<br>          <span class="hljs-meta">if</span> (res.<span class="hljs-meta">length</span> === 0) <span class="hljs-meta">return</span> <span class="hljs-string">&quot;&quot;</span><br>          break;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-meta">return</span> res.jo<span class="hljs-meta">in(</span><span class="hljs-string">&#x27;&#x27;</span>)<br>&#125;;<br></code></pre></td></tr></table></figure><p>暴力查找就很简单了，一次次的遍历，然后和公共的<code>res</code>对比，一直对比到最后即可。</p><h4 id="更好的方法（排序）"><a href="#更好的方法（排序）" class="headerlink" title="更好的方法（排序）"></a>更好的方法（排序）</h4><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">var</span> longestCommonPrefix = <span class="hljs-function"><span class="hljs-keyword">function</span></span>(strs) &#123;<br>  <span class="hljs-keyword">var</span> res = []<br>  <span class="hljs-comment">// 处理特殊情况</span><br>  <span class="hljs-keyword">if</span> (strs.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-keyword">if</span> (strs.length === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> strs[<span class="hljs-number">0</span>]<br>  <span class="hljs-comment">// 对数组进行排序，正序倒序无所谓</span><br>  <span class="hljs-keyword">var</span> <span class="hljs-keyword">new</span><span class="hljs-type">Arr</span> = strs.sort()<br>  <span class="hljs-comment">// 拿到第一个元素和最后一个元素</span><br>  <span class="hljs-keyword">var</span> lastArr = <span class="hljs-keyword">new</span><span class="hljs-type">Arr</span>[<span class="hljs-keyword">new</span><span class="hljs-type">Arr</span>.length - <span class="hljs-number">1</span>].split(<span class="hljs-string">&#x27;&#x27;</span>)<br>  <span class="hljs-keyword">var</span> firstArr = <span class="hljs-keyword">new</span><span class="hljs-type">Arr</span>[<span class="hljs-number">0</span>].split(<span class="hljs-string">&#x27;&#x27;</span>)<br>  <span class="hljs-comment">// 有空字符串的之后返回空</span><br>  <span class="hljs-keyword">if</span> (firstArr.length === <span class="hljs-number">0</span> || lastArr.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span><br>  <span class="hljs-comment">// 比较第一个和最后一个元素，取它们的共同前缀即可</span><br>  <span class="hljs-keyword">for</span> (let index = <span class="hljs-number">0</span>; index &lt; lastArr.length; index++) &#123;<br>    <span class="hljs-keyword">if</span> (lastArr[index] === firstArr[index]) &#123;<br>      res.push(lastArr[index])<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>  &#125;<br><span class="hljs-comment">// 返回前缀</span><br>  <span class="hljs-keyword">return</span> res.join(<span class="hljs-string">&#x27;&#x27;</span>)<br>&#125;;<br></code></pre></td></tr></table></figure><p>代码写起来很简单，就是想到这一点很难。</p><p>首先经典排序，字符串的排序其实是按照字母出现的顺序进行排序的，举个🌰：</p><blockquote><p>给定数组<code>[&#39;fun&#39;, &#39;funny&#39;, &#39;find&#39;]</code></p></blockquote><p>对其进行排序：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> strs = <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;fun&#x27;</span>, <span class="hljs-string">&#x27;funny&#x27;</span>, <span class="hljs-string">&#x27;find&#x27;</span>]</span><br>strs<span class="hljs-selector-class">.sort</span>()<br></code></pre></td></tr></table></figure><p>打印<code>strs</code>：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">console.log(strs)<span class="hljs-regexp">//</span> [<span class="hljs-string">&quot;find&quot;</span>, <span class="hljs-string">&quot;fun&quot;</span>, <span class="hljs-string">&quot;funny&quot;</span>]<br></code></pre></td></tr></table></figure><p>首先对第一个字母进行排序，由于大家都是<code>f</code>开头，所以不管；接下来看第二个字母，分别是<code>u</code>、<code>u</code>和<code>i</code>。</p><p>那么排序之后就是<code>[&quot;find&quot;, &quot;funny&quot;, &quot;fun&quot;]</code>。</p><p>接下来第三个字母，由于<code>find</code>已经领先剩下两个字母了，所以不用管，大家都是<code>n</code>，会继续比较下一个，然后就这样一点点的比较，可以拿到排序之后的<code>strs</code>。</p><p>那么此时拿到的第一个和最后一个就是排好序的字符串了，排序的要求也是按照字母出现的顺序。</p><p>现在只要拿最后一个和第一个进行比较，即可得出整个数组的最长公共前缀。</p><p>实现确实很简单，难的是想到这一点。</p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前端刷题路-Day1</title>
    <link href="/rexkentzheng/2021/03/18/%E5%89%8D%E7%AB%AF%E5%88%B7%E9%A2%98%E8%B7%AF-Day1/"/>
    <url>/rexkentzheng/2021/03/18/%E5%89%8D%E7%AB%AF%E5%88%B7%E9%A2%98%E8%B7%AF-Day1/</url>
    
    <content type="html"><![CDATA[<h3 id="两数之和（题号1）"><a href="#两数之和（题号1）" class="headerlink" title="两数之和（题号1）"></a>两数之和（题号1）</h3><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p>你可以按任意顺序返回答案。</p><p>示例 1：<br>输入：nums = [2,7,11,15], target = 9<br>输出：[0,1]<br>解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。  </p><p>示例 2：<br>输入：nums = [3,2,4], target = 6<br>输出：[1,2]</p><p>示例 3：<br>输入：nums = [3,3], target = 6<br>输出：[0,1]  </p><p>提示：<br>2 &lt;= nums.length &lt;= 103<br>-109 &lt;= nums[i] &lt;= 109<br>-109 &lt;= target &lt;= 109<br>只会存在一个有效答案  </p><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p><a href="https://leetcode-cn.com/problems/two-sum/">https://leetcode-cn.com/problems/two-sum/</a></p><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>要开始研究算法，LeetCode必不可少。</p><p>要刷LeetCode，自然要从第一题开始。</p><p>这题是简单题，如果想到那种方法就很简单了，想不到的话可能就是想不到了。</p><p>想找到两个和为<code>target</code>的数，可以换个思路，先找到<code>target</code>和一个数的差，如果后续循环的时候，有某一个数字在这一堆差里头，那么找到这个差的<code>index</code>和当前的<code>index</code>即可。</p><p>而且注意题目的描述：</p><blockquote><p>只会存在一个有效答案</p></blockquote><p>那就是不存在没有答案的情况，特殊情况也不用考虑了，十分简单。</p><h4 id="自己的答案（数组）"><a href="#自己的答案（数组）" class="headerlink" title="自己的答案（数组）"></a>自己的答案（数组）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> twoSum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">nums, target</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> arr = []<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>    <span class="hljs-keyword">var</span> res = arr.findIndex(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item === nums[i])<br>    <span class="hljs-keyword">if</span> (res &gt; -<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> [res, i]<br>    arr[i] = target - nums[i]    <br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里是利用的数组的<code>findIndex()</code>方法，因为对具体的值不敏感，只关心它的<code>index</code>。</p><h4 id="自己的答案（Map）"><a href="#自己的答案（Map）" class="headerlink" title="自己的答案（Map）"></a>自己的答案（<code>Map</code>）</h4><p>同<code>Map</code>的话性能会好一些，毕竟它的读写比数组快，而且不需要写判断条件。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> twoSum = function(nums, target) &#123;<br>  <span class="hljs-keyword">var</span> <span class="hljs-keyword">group</span> = <span class="hljs-keyword">new</span> Map()<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">group</span>.has(nums[i])) <span class="hljs-keyword">return</span> [<span class="hljs-keyword">group</span>.<span class="hljs-keyword">get</span>(nums[i]), i]<br>    <span class="hljs-keyword">group</span>.<span class="hljs-keyword">set</span>(target - nums[i], i)<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>答案就是这样，很清晰易懂</p><p>这题主要考的是哈希表，第一步存储差到数组或者<code>Map</code>中就是一个哈希表，之后在表里查找正确答案就行了，笔者看了看其他的一些答案，<code>JavaScript</code>基本上都是这个解法，如果更好的方法欢迎在评论区指出</p><h4 id="更好的方法"><a href="#更好的方法" class="headerlink" title="更好的方法"></a>更好的方法</h4><p>无</p><h3 id="整数反转（题号7）"><a href="#整数反转（题号7）" class="headerlink" title="整数反转（题号7）"></a>整数反转（题号7）</h3><h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><p>给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。</p><p>如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。</p><p>假设环境不允许存储 64 位整数（有符号或无符号）。</p><p>示例 1：<br>输入：x = 123<br>输出：321  </p><p>示例 2：<br>输入：x = -123<br>输出：-321  </p><p>示例 3：<br>输入：x = 120<br>输出：21  </p><p>示例 4：<br>输入：x = 0<br>输出：0  </p><p>提示：<br>-231 &lt;= x &lt;= 231 - 1</p><h4 id="链接-1"><a href="#链接-1" class="headerlink" title="链接"></a>链接</h4><p><a href="https://leetcode-cn.com/problems/reverse-integer/">https://leetcode-cn.com/problems/reverse-integer/</a></p><h4 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h4><p>看到这题的第一眼就已经想好了做法，的确，这种方法的确是可行的，但其实还有另外一种方法。</p><h4 id="自己的答案（经典数组）"><a href="#自己的答案（经典数组）" class="headerlink" title="自己的答案（经典数组）"></a>自己的答案（经典数组）</h4><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">var</span> <span class="hljs-built_in">reverse</span> = function(x) &#123;<br>  <span class="hljs-built_in">var</span> <span class="hljs-built_in">num</span> = +Math.<span class="hljs-built_in">abs</span>(x).toString().<span class="hljs-built_in">split</span>(&#x27;&#x27;).<span class="hljs-built_in">reverse</span>().<span class="hljs-built_in">join</span>(&#x27;&#x27;)<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">num</span> &gt; Math.pow(<span class="hljs-number">2</span>, <span class="hljs-number">31</span>) - <span class="hljs-number">1</span> || <span class="hljs-built_in">num</span> &lt; Math.pow(-<span class="hljs-number">2</span>, <span class="hljs-number">31</span>)) <span class="hljs-built_in">return</span> <span class="hljs-number">0</span><br>  <span class="hljs-built_in">return</span> x &lt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> - +<span class="hljs-built_in">num</span> : +<span class="hljs-built_in">num</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>说实话，性能并不比另外一种差，可以说是不相伯仲。</p><blockquote><p>执行用时：88 ms, 在所有 JavaScript 提交中击败了96.37%的用户</p><p>内存消耗：39 MB, 在所有 JavaScript 提交中击败了96.66%的用户</p></blockquote><h4 id="更好的方法（位运算）"><a href="#更好的方法（位运算）" class="headerlink" title="更好的方法（位运算）"></a>更好的方法（位运算）</h4><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">var</span> reverse = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> res = <span class="hljs-number">0</span><br>  <span class="hljs-keyword">while</span> (x) &#123;<br>    <span class="hljs-comment">// res每次增加10倍，然后加上新增的数据</span><br>    res = res * <span class="hljs-number">10</span> + x % <span class="hljs-number">10</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.abs(res) &gt; <span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">31</span>)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-comment">// 一个～是按位取反，两个～～是直接去掉小数点后面的内容</span><br>    <span class="hljs-comment">// 而且～～不会改变数字的正负，这一点比Math.floor()强不少</span><br>    x = ~~(x/<span class="hljs-number">10</span>)<br>  &#125;<br>  <span class="hljs-keyword">return</span> res<br>&#125;;<br></code></pre></td></tr></table></figure><p>其实就是10位10位的累加，又点类似于有经典是10位进1的操作，但又有些许不同。</p><p>这样对<code>x</code>一次次对遍历，最终<code>x</code>会被拆解为0，拆解完成时还没越界就直接返回<code>res</code>。</p><h3 id="回文数（题号9）"><a href="#回文数（题号9）" class="headerlink" title="回文数（题号9）"></a>回文数（题号9）</h3><h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><p>给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。</p><p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。</p><p>示例 1：<br>输入：x = 121<br>输出：true  </p><p>示例 2：<br>输入：x = -121<br>输出：false<br>解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。  </p><p>示例 3：<br>输入：x = 10<br>输出：false<br>解释：从右向左读, 为 01 。因此它不是一个回文数。  </p><p>示例 4：<br>输入：x = -101<br>输出：false</p><p>提示：</p><p>-231 &lt;= x &lt;= 231 - 1</p><p>进阶：你能不将整数转为字符串来解决这个问题吗？</p><h4 id="链接-2"><a href="#链接-2" class="headerlink" title="链接"></a>链接</h4><p><a href="https://leetcode-cn.com/problems/palindrome-number/">https://leetcode-cn.com/problems/palindrome-number/</a></p><h4 id="解释-2"><a href="#解释-2" class="headerlink" title="解释"></a>解释</h4><p>其实和上面的整数反转的代码差不多，就是可以通过一些判断直接过滤掉一些结果。</p><p>比方说负数必然不会时回文数，还有就是可以被10整除的数，因为被10整除的数最后一位必然是0，但没有数字是以0开头的。</p><h4 id="自己的答案（位运算）"><a href="#自己的答案（位运算）" class="headerlink" title="自己的答案（位运算）"></a>自己的答案（位运算）</h4><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sas">var isPalindrome = functi<span class="hljs-meta">on(</span><span class="hljs-meta">x</span>) &#123;<br>  <span class="hljs-meta">if</span> (<span class="hljs-meta">x</span> &lt; 0 || (<span class="hljs-meta">x</span> &gt; 0 <span class="hljs-variable">&amp;&amp;</span> <span class="hljs-meta">x</span> % 10 === 0)) <span class="hljs-meta">return</span> false<br>  var xBefore = <span class="hljs-meta">x</span><br>      xEnd = 0<br>  <span class="hljs-meta">while</span> (<span class="hljs-meta">x</span>) &#123;<br>    xEnd = xEnd <span class="hljs-comment">* 10 + x % 10</span><br><span class="hljs-comment">    x = ~~(x / 10)</span><br><span class="hljs-comment">  &#125;</span><br><span class="hljs-comment">  return xBefore === xEnd</span><br><span class="hljs-comment">&#125;;</span><br></code></pre></td></tr></table></figure><p>跑得也还不错，抽风的时候可以跑到下面这个成绩，感觉LeetCode是用时和内存消耗很不稳定，没谱的事。</p><blockquote><p>执行用时：196 ms, 在所有 JavaScript 提交中击败了92.80%的用户</p><p>内存消耗：46.2 MB, 在所有 JavaScript 提交中击败了97.63%的用户</p></blockquote><h4 id="更好的方法（数学算法）"><a href="#更好的方法（数学算法）" class="headerlink" title="更好的方法（数学算法）"></a>更好的方法（数学算法）</h4><p>这块就有点超纲了，感觉这辈子都写不出这样的代码，贴一下地址吧：</p><p><a href="https://leetcode-cn.com/problems/palindrome-number/solution/ji-jian-jie-fa-by-ijzqardmbd-2/">https://leetcode-cn.com/problems/palindrome-number/solution/ji-jian-jie-fa-by-ijzqardmbd-2/</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前端刷题路-Day0</title>
    <link href="/rexkentzheng/2021/03/15/%E5%89%8D%E7%AB%AF%E5%88%B7%E9%A2%98%E8%B7%AF-Day0/"/>
    <url>/rexkentzheng/2021/03/15/%E5%89%8D%E7%AB%AF%E5%88%B7%E9%A2%98%E8%B7%AF-Day0/</url>
    
    <content type="html"><![CDATA[<p>这一章可能是一系列Leetcode解题文章的开始，也有可能坚持不了多久，这都没谱的事。<br>作为前端来说，刷算法题确实是很尴尬的一件事，平常的工作中根本用不到，问的人也很少，笔者被问到算法的情况也屈指可数，因此在大多数人眼中算法其实没有多大的意义。<br>笔者这里开始刷算法题的原因很简单，就是想试试，因为之前没接触过算法题，只是在同事的代码中见过很少的一部分，觉得很强。<br>而且现在天天写业务写得生无可恋，再不找点好玩的事情做就真得自闭了。在合理的范围内试试一种全新的东西，应该是很好玩的一件事。而且感觉算法如果学好了看很多东西可以更通透，那种感觉不言而喻。<br>这一系列的文章就是记录笔者的整体刷题过程了，纬度是天，有时一天刷一题，有时可能会刷个两三题，看看当天的时间吧。<br>然后会当上自己的思路，自己的答案和更好的方法，对比一下，看看有没有可能提升的地方。<br>这肯定会是个很难的过程，总得开始迈出第一步啊。<br>路漫漫其修远兮，吾将上下而求索。  </p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
